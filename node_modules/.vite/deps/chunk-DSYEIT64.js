import {
  scaleValue
} from "./chunk-52WLLNIP.js";
import {
  debounce,
  isObject
} from "./chunk-CDBVSAJQ.js";

// node_modules/@revolist/revogrid/dist/esm/throttle-DcjZyclk.js
var initialParams = {
  contentSize: 0,
  clientSize: 0,
  virtualSize: 0,
  maxSize: 0
};
var NO_COORDINATE = -1;
function getContentSize(contentSize, clientSize, virtualSize = 0) {
  if (virtualSize > contentSize) {
    return 0;
  }
  return contentSize + (virtualSize ? clientSize - virtualSize : 0);
}
var LocalScrollService = class {
  constructor(cfg) {
    this.cfg = cfg;
    this.preventArtificialScroll = {
      rgRow: null,
      rgCol: null
    };
    this.previousScroll = {
      rgRow: NO_COORDINATE,
      rgCol: NO_COORDINATE
    };
    this.params = {
      rgRow: Object.assign({}, initialParams),
      rgCol: Object.assign({}, initialParams)
    };
  }
  setParams(params, dimension) {
    const virtualContentSize = getContentSize(params.contentSize, params.clientSize, params.virtualSize);
    this.params[dimension] = Object.assign(Object.assign({}, params), { maxSize: virtualContentSize - params.clientSize, virtualContentSize });
  }
  // apply scroll values after scroll done
  async setScroll(e) {
    this.cancelScroll(e.dimension);
    const frameAnimation = new Promise((resolve, reject) => {
      if (this.cfg.skipAnimationFrame) {
        return resolve();
      }
      const animationId = window.requestAnimationFrame(() => {
        resolve();
      });
      this.preventArtificialScroll[e.dimension] = reject.bind(null, animationId);
    });
    try {
      await frameAnimation;
      const params = this.getParams(e.dimension);
      e.coordinate = Math.ceil(e.coordinate);
      this.previousScroll[e.dimension] = this.wrapCoordinate(e.coordinate, params);
      this.preventArtificialScroll[e.dimension] = null;
      this.cfg.applyScroll(Object.assign(Object.assign({}, e), { coordinate: params.virtualSize ? this.convert(e.coordinate, params, false) : e.coordinate }));
    } catch (id) {
      window.cancelAnimationFrame(id);
    }
  }
  /**
   * On scroll event started
   */
  scroll(coordinate, dimension, force = false, delta, outside = false) {
    this.cancelScroll(dimension);
    if (!force && this.previousScroll[dimension] === coordinate) {
      this.previousScroll[dimension] = NO_COORDINATE;
      return;
    }
    const param = this.getParams(dimension);
    this.cfg.runScroll({
      dimension,
      coordinate: param.virtualSize ? this.convert(coordinate, param) : coordinate,
      delta,
      outside
    });
  }
  getParams(dimension) {
    return this.params[dimension];
  }
  // check if scroll outside of region to avoid looping
  wrapCoordinate(c, param) {
    if (c < 0) {
      return NO_COORDINATE;
    }
    if (typeof param.maxSize === "number" && c > param.maxSize) {
      return param.maxSize;
    }
    return c;
  }
  // prevent already started scroll, performance optimization
  cancelScroll(dimension) {
    var _a, _b;
    (_b = (_a = this.preventArtificialScroll)[dimension]) === null || _b === void 0 ? void 0 : _b.call(_a);
    this.preventArtificialScroll[dimension] = null;
  }
  /* convert virtual to real and back, scale range */
  convert(pos, param, toReal = true) {
    var _a;
    const minRange = param.clientSize;
    const from = [0, ((_a = param.virtualContentSize) !== null && _a !== void 0 ? _a : minRange) - minRange];
    const to = [0, param.contentSize - param.virtualSize];
    if (toReal) {
      return scaleValue(pos, from, to);
    }
    return scaleValue(pos, to, from);
  }
};
var LocalScrollTimer = class {
  constructor(scrollThrottling = 10) {
    this.scrollThrottling = scrollThrottling;
    this.mouseWheelScrollTimestamp = {
      rgCol: 0,
      rgRow: 0
    };
    this.lastKnownScrollCoordinate = {
      rgCol: 0,
      rgRow: 0
    };
    this.lastScrollUpdateCallbacks = {};
  }
  setCoordinate(e) {
    this.lastKnownScrollCoordinate[e.dimension] = e.coordinate;
  }
  /**
   * Remember last mw event time
   */
  latestScrollUpdate(dimension) {
    this.mouseWheelScrollTimestamp[dimension] = (/* @__PURE__ */ new Date()).getTime();
  }
  isReady(type, coordinate) {
    if (this.lastScrollUpdateCallbacks[type]) {
      this.clearLastScrollUpdate(type);
    }
    return this.verifyChange(type, coordinate);
  }
  verifyChange(type, coordinate) {
    const now = (/* @__PURE__ */ new Date()).getTime();
    const change = now - this.mouseWheelScrollTimestamp[type];
    return change > this.scrollThrottling && coordinate !== this.lastKnownScrollCoordinate[type];
  }
  clearLastScrollUpdate(type) {
    var _a, _b;
    clearTimeout((_b = (_a = this.lastScrollUpdateCallbacks[type]) === null || _a === void 0 ? void 0 : _a.timeout) !== null && _b !== void 0 ? _b : 0);
    delete this.lastScrollUpdateCallbacks[type];
  }
  throttleLastScrollUpdate(type, coordinate, lastScrollUpdate) {
    if (this.scrollThrottling) {
      this.clearLastScrollUpdate(type);
      const callback = this.lastScrollUpdateCallbacks[type] = {
        callback: lastScrollUpdate,
        timestamp: (/* @__PURE__ */ new Date()).getTime(),
        coordinate,
        timeout: 0
      };
      callback.timeout = setTimeout(() => {
        this.clearLastScrollUpdate(type);
        if (this.mouseWheelScrollTimestamp[type] < callback.timestamp && this.verifyChange(type, callback.coordinate)) {
          callback.callback();
        }
      }, this.scrollThrottling + 50);
    }
  }
};
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}

export {
  getContentSize,
  LocalScrollService,
  LocalScrollTimer,
  throttle
};
/*! Bundled license information:

@revolist/revogrid/dist/esm/throttle-DcjZyclk.js:
  (*!
   * Built by Revolist OU ❤️
   *)
*/
//# sourceMappingURL=chunk-DSYEIT64.js.map
