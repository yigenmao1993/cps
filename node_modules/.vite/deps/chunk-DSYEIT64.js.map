{
  "version": 3,
  "sources": ["../../@revolist/revogrid/dist/esm/src/services/local.scroll.service.ts", "../../@revolist/revogrid/dist/esm/src/services/local.scroll.timer.ts", "../../@revolist/revogrid/dist/esm/node_modules/lodash/throttle.js"],
  "sourcesContent": ["import type { DimensionType, ViewPortScrollEvent } from '@type';\nimport { scaleValue } from '../utils';\n\ninterface Config {\n  skipAnimationFrame?: boolean;\n  // scroll event inited and direction cached\n  // scrollingService.proxyScroll get tiggered\n  // setScroll event called from scrollingService\n  runScroll(e: ViewPortScrollEvent): void;\n  // all operation finished, apply scroll values\n  applyScroll(e: ViewPortScrollEvent): void;\n}\n\ntype Params = {\n  contentSize: number;\n  virtualContentSize?: number;\n  clientSize: number;\n  virtualSize: number;\n  maxSize?: number;\n};\n\nconst initialParams: Params = {\n  contentSize: 0,\n  clientSize: 0,\n  virtualSize: 0,\n  maxSize: 0,\n};\nconst NO_COORDINATE = -1;\n\n/**\n * Based on content size, client size and virtual size\n * return full size\n */\nexport function getContentSize(\n  contentSize: number,\n  clientSize: number,\n  virtualSize = 0,\n): number {\n  if (virtualSize > contentSize) {\n    return 0;\n  }\n  return contentSize + (virtualSize ? clientSize - virtualSize : 0);\n}\n\nexport default class LocalScrollService {\n  private preventArtificialScroll: Record<DimensionType, (() => void) | null> = {\n    rgRow: null,\n    rgCol: null,\n  };\n  // to check if scroll changed\n  private previousScroll: Record<DimensionType, number> = {\n    rgRow: NO_COORDINATE,\n    rgCol: NO_COORDINATE,\n  };\n  private params: Record<DimensionType, Params> = {\n    rgRow: { ...initialParams },\n    rgCol: { ...initialParams },\n  };\n\n  constructor(private cfg: Config) {}\n\n  setParams(params: Params, dimension: DimensionType) {\n    const virtualContentSize = getContentSize(\n      params.contentSize,\n      params.clientSize,\n      params.virtualSize,\n    );\n    this.params[dimension] = {\n      ...params,\n      maxSize: virtualContentSize - params.clientSize,\n      virtualContentSize,\n    };\n  }\n\n  // apply scroll values after scroll done\n  async setScroll(e: ViewPortScrollEvent) {\n    this.cancelScroll(e.dimension);\n\n    // start frame animation\n    const frameAnimation = new Promise<void>((resolve, reject) => {\n      // for example safari desktop has issues with animation frame\n      if (this.cfg.skipAnimationFrame) {\n        return resolve();\n      }\n      const animationId = window.requestAnimationFrame(() => {\n        resolve();\n      });\n      this.preventArtificialScroll[e.dimension] = reject.bind(\n        null,\n        animationId,\n      );\n    });\n\n    try {\n      await frameAnimation;\n      const params = this.getParams(e.dimension);\n      e.coordinate = Math.ceil(e.coordinate);\n      this.previousScroll[e.dimension] = this.wrapCoordinate(\n        e.coordinate,\n        params,\n      );\n      this.preventArtificialScroll[e.dimension] = null;\n      this.cfg.applyScroll({\n        ...e,\n        coordinate: params.virtualSize\n          ? this.convert(e.coordinate, params, false)\n          : e.coordinate,\n      });\n    } catch (id) {\n      window.cancelAnimationFrame(id);\n    }\n  }\n\n  /**\n   * On scroll event started\n   */\n  scroll(\n    coordinate: number,\n    dimension: DimensionType,\n    force = false,\n    delta?: number,\n    outside = false,\n  ) {\n    // cancel all previous scrolls for same dimension\n    this.cancelScroll(dimension);\n\n    // drop if no change\n    if (!force && this.previousScroll[dimension] === coordinate) {\n      this.previousScroll[dimension] = NO_COORDINATE;\n      return;\n    }\n\n    const param = this.getParams(dimension);\n    // let component know about scroll event started\n    this.cfg.runScroll({\n      dimension: dimension,\n      coordinate: param.virtualSize\n        ? this.convert(coordinate, param)\n        : coordinate,\n      delta,\n      outside,\n    });\n  }\n\n  private getParams(dimension: DimensionType): Params {\n    return this.params[dimension];\n  }\n\n  // check if scroll outside of region to avoid looping\n  private wrapCoordinate(c: number, param: Params): number {\n    if (c < 0) {\n      return NO_COORDINATE;\n    }\n\n    if (typeof param.maxSize === 'number' && c > param.maxSize) {\n      return param.maxSize;\n    }\n    return c;\n  }\n\n  // prevent already started scroll, performance optimization\n  private cancelScroll(dimension: DimensionType) {\n    this.preventArtificialScroll[dimension]?.();\n    this.preventArtificialScroll[dimension] = null;\n  }\n\n  /* convert virtual to real and back, scale range */\n  private convert(pos: number, param: Params, toReal = true): number {\n    const minRange = param.clientSize;\n    const from: [number, number] = [0, (param.virtualContentSize ?? minRange) - minRange];\n    const to: [number, number] = [0, param.contentSize - param.virtualSize];\n    if (toReal) {\n      return scaleValue(pos, from, to);\n    }\n    return scaleValue(pos, to, from);\n  }\n}\n", "import type { DimensionType } from '@type';\n/**\n * Apply changes only if mousewheel event happened some time ago (scrollThrottling)\n */\nexport class LocalScrollTimer {\n  /**\n   * Last mw event time for trigger scroll function below\n   * If mousewheel function was ignored we still need to trigger render\n   */\n  private mouseWheelScrollTimestamp: Record<DimensionType, number> = {\n    rgCol: 0,\n    rgRow: 0,\n  };\n  private lastKnownScrollCoordinate: Record<DimensionType, number> = {\n    rgCol: 0,\n    rgRow: 0,\n  };\n\n  constructor(private scrollThrottling = 10) {}\n\n  setCoordinate(e: { dimension: DimensionType; coordinate: number }) {\n    this.lastKnownScrollCoordinate[e.dimension] = e.coordinate;\n  }\n\n  /**\n   * Remember last mw event time\n   */\n  latestScrollUpdate(dimension: DimensionType) {\n    this.mouseWheelScrollTimestamp[dimension] = new Date().getTime();\n  }\n\n  isReady(type: DimensionType, coordinate: number) {\n    // if there is a callback, clear it\n    if (this.lastScrollUpdateCallbacks[type]) {\n      this.clearLastScrollUpdate(type)\n    }\n    // apply after throttling\n    return this.verifyChange(type, coordinate);\n  }\n\n  private verifyChange(type: DimensionType, coordinate: number) {\n    const now = new Date().getTime();\n    const change = now - this.mouseWheelScrollTimestamp[type];\n    return change > this.scrollThrottling &&\n    coordinate !== this.lastKnownScrollCoordinate[type];\n  }\n\n  /**\n   * Check if scroll is ready to accept new value\n   * this is an edge case for scroll events\n   * when we need to apply scroll after throttling\n   */\n  private lastScrollUpdateCallbacks: Partial<Record<DimensionType, {\n    callback: () => void;\n    timestamp: number;\n    coordinate: number;\n    timeout: number;\n  }>> = {};\n\n  private clearLastScrollUpdate(type: DimensionType) {\n    clearTimeout(this.lastScrollUpdateCallbacks[type]?.timeout ?? 0);\n    delete this.lastScrollUpdateCallbacks[type];\n  }\n\n  throttleLastScrollUpdate(type: DimensionType, coordinate: number, lastScrollUpdate: () => void) {\n    // if scrollThrottling is set\n    // we need to throttle the last scroll event\n    if (this.scrollThrottling) {\n      this.clearLastScrollUpdate(type)\n      // save lastScrollUpdate callback\n      const callback = this.lastScrollUpdateCallbacks[type] = {\n        callback: lastScrollUpdate,\n        timestamp: new Date().getTime(),\n        coordinate,\n        timeout: 0 as any,\n      };\n      callback.timeout = setTimeout(() => {\n        // clear timeout\n        this.clearLastScrollUpdate(type)\n        // if scrollThrottling is set, and the last scroll event happened before the timeout started\n        // we need to throttle the last scroll event\n        if (this.mouseWheelScrollTimestamp[type] < callback.timestamp && this.verifyChange(type, callback.coordinate)) {\n          callback.callback();\n        }\n      }, this.scrollThrottling + 50);\n    }\n  }\n}\n", "import debounce from './debounce.js';\nimport isObject from './isObject.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nexport default throttle;\n"],
  "mappings": "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",
  "names": []
}
