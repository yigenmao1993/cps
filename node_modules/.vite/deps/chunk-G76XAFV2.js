import {
  calculateRowHeaderSize
} from "./chunk-YXORL5PL.js";
import {
  ON_COLUMN_CLICK,
  dispatch
} from "./chunk-QG7UZVRU.js";
import {
  GROUPING_ROW_TYPE,
  GROUP_DEPTH,
  GROUP_EXPANDED,
  GROUP_EXPAND_EVENT,
  PSEUDO_GROUP_COLUMN,
  PSEUDO_GROUP_ITEM_ID,
  PSEUDO_GROUP_ITEM_VALUE,
  baseEach,
  columnTypes,
  gatherGrouping,
  getCellDataParsed,
  getCellRaw,
  getColumnByProp,
  getColumnType,
  getExpanded,
  getGroupingName,
  getParsedGroup,
  getRange,
  getSource,
  isColGrouping,
  isGrouping,
  isGroupingColumn,
  isSameGroup,
  reduce,
  rowTypes,
  toInteger
} from "./chunk-QZAIXLNJ.js";
import {
  baseKeys,
  baseProperty,
  calculateDimensionData,
  createStore,
  getItemByPosition,
  getPhysical,
  getScrollbarSize,
  getSourceItem,
  getTag,
  identity,
  isArray,
  isArrayLike,
  setItems,
  setStore,
  timeout
} from "./chunk-52WLLNIP.js";
import {
  FILTER_PROP,
  isFilterBtn
} from "./chunk-BEN4J7WE.js";
import {
  baseGetTag,
  debounce,
  h,
  isObjectLike
} from "./chunk-CDBVSAJQ.js";

// node_modules/@revolist/revogrid/dist/esm/column.drag.plugin-CmcURdIJ.js
var recalculateRealSizePlugin = (storeService) => {
  return {
    /**
     * Reacts on changes of count, sizes and originItemSize
     */
    set(k) {
      switch (k) {
        case "count":
        case "sizes":
        case "originItemSize": {
          let realSize = 0;
          const count = storeService.store.get("count");
          for (let i = 0; i < count; i++) {
            realSize += storeService.store.get("sizes")[i] || storeService.store.get("originItemSize");
          }
          storeService.setStore({ realSize });
          break;
        }
      }
    }
  };
};
var trimmedPlugin = (storeService) => {
  let trimmingObject = null;
  let trimmedPreviousSizes = null;
  return {
    set(key, val) {
      switch (key) {
        case "sizes": {
          if (trimmingObject && trimmingObject === val) {
            trimmingObject = null;
            return;
          }
          trimmedPreviousSizes = null;
          break;
        }
        case "trimmed": {
          const trim = val;
          if (!trimmedPreviousSizes) {
            trimmedPreviousSizes = storeService.store.get("sizes");
          }
          trimmingObject = removeMultipleAndShift(trimmedPreviousSizes, trim || {});
          storeService.setSizes(trimmingObject);
          break;
        }
      }
    }
  };
};
function removeMultipleAndShift(items, toRemove) {
  const newItems = {};
  const sortedIndexes = Object.keys(items || {}).map(Number).sort((a, b) => a - b);
  const lastIndex = sortedIndexes[sortedIndexes.length - 1];
  let shift = 0;
  for (let i = 0; i <= lastIndex; i++) {
    if (toRemove[i] !== void 0) {
      shift++;
      if (items[i] !== void 0) {
        continue;
      }
    }
    if (items[i] !== void 0) {
      newItems[i - shift] = items[i];
    }
  }
  return newItems;
}
function initialBase() {
  return {
    indexes: [],
    count: 0,
    // hidden items
    trimmed: null,
    // virtual item index to size
    sizes: {},
    // order in indexes[] to coordinate
    positionIndexToItem: {},
    // initial element to coordinate ^
    indexToItem: {},
    positionIndexes: []
  };
}
function initialState() {
  return Object.assign(Object.assign({}, initialBase()), {
    // size which all items can take
    realSize: 0,
    // initial item size if it wasn't changed
    originItemSize: 0
  });
}
var DimensionStore = class {
  constructor(type) {
    this.type = type;
    this.store = createStore(initialState());
    this.store.use(trimmedPlugin({
      store: this.store,
      setSizes: this.setDimensionSize.bind(this)
    }));
    this.store.use(recalculateRealSizePlugin({
      store: this.store,
      setStore: this.setStore.bind(this)
    }));
  }
  getCurrentState() {
    const state = initialState();
    const keys = Object.keys(state);
    return reduce(keys, (r, k) => {
      const data = this.store.get(k);
      r[k] = data;
      return r;
    }, state);
  }
  dispose() {
    setStore(this.store, initialState());
  }
  setStore(data) {
    setStore(this.store, data);
  }
  drop() {
    setStore(this.store, initialBase());
  }
  /**
   * Set custom dimension sizes and overwrite old
   * Generates new indexes based on sizes
   * @param sizes - sizes to set
   */
  setDimensionSize(sizes = {}) {
    const dimensionData = calculateDimensionData(this.store.get("originItemSize"), sizes);
    setStore(this.store, Object.assign(Object.assign({}, dimensionData), { sizes }));
  }
  updateSizesPositionByIndexes(newItemsOrder, prevItemsOrder = []) {
    const customSizes = Object.assign({}, this.store.get("sizes"));
    if (!Object.keys(customSizes).length) {
      return;
    }
    const originalIndices = {};
    prevItemsOrder.forEach((physIndex, virtIndex) => {
      if (!originalIndices[physIndex]) {
        originalIndices[physIndex] = [];
      }
      originalIndices[physIndex].push(virtIndex);
    });
    const newSizes = {};
    newItemsOrder.forEach((physIndex, virtIndex) => {
      const indices = originalIndices[physIndex];
      if (indices && indices.length > 0) {
        const originalIndex = indices.shift();
        if (originalIndex !== void 0 && originalIndex !== virtIndex && customSizes[originalIndex]) {
          newSizes[virtIndex] = customSizes[originalIndex];
          delete customSizes[originalIndex];
        }
      }
    });
    if (Object.keys(newSizes).length) {
      this.setDimensionSize(Object.assign(Object.assign({}, customSizes), newSizes));
    }
  }
};
function defaultState() {
  return {
    range: null,
    tempRange: null,
    tempRangeType: null,
    focus: null,
    edit: null,
    lastCell: null,
    nextFocus: null
  };
}
var SelectionStore = class {
  constructor() {
    this.unsubscribe = [];
    this.store = createStore(defaultState());
    this.store.on("set", (key, newVal) => {
      if (key === "tempRange" && !newVal) {
        this.store.set("tempRangeType", null);
      }
    });
  }
  onChange(propName, cb) {
    this.unsubscribe.push(this.store.onChange(propName, cb));
  }
  clearFocus() {
    setStore(this.store, { focus: null, range: null, edit: null, tempRange: null });
  }
  setFocus(focus, end) {
    if (!end) {
      setStore(this.store, { focus });
    } else {
      setStore(this.store, {
        focus,
        range: getRange(focus, end),
        edit: null,
        tempRange: null
      });
    }
  }
  setNextFocus(focus) {
    setStore(this.store, { nextFocus: focus });
  }
  setTempArea(range) {
    setStore(this.store, { tempRange: range === null || range === void 0 ? void 0 : range.area, tempRangeType: range === null || range === void 0 ? void 0 : range.type, edit: null });
  }
  clearTemp() {
    setStore(this.store, { tempRange: null });
  }
  /** Can be applied from selection change or from simple keyboard change clicks */
  setRangeArea(range) {
    setStore(this.store, { range, edit: null, tempRange: null });
  }
  setRange(start, end) {
    const range = getRange(start, end);
    this.setRangeArea(range);
  }
  setLastCell(lastCell) {
    setStore(this.store, { lastCell });
  }
  setEdit(val) {
    const focus = this.store.get("focus");
    if (focus && typeof val === "string") {
      setStore(this.store, {
        edit: { x: focus.x, y: focus.y, val }
      });
      return;
    }
    setStore(this.store, { edit: null });
  }
  dispose() {
    this.unsubscribe.forEach((f) => f());
    this.store.dispose();
  }
};
var BasePlugin = class {
  constructor(revogrid, providers) {
    this.revogrid = revogrid;
    this.providers = providers;
    this.h = h;
    this.subscriptions = {};
  }
  /**
   *
   * @param eventName - event name to subscribe to in revo-grid component (e.g. 'beforeheaderclick')
   * @param callback - callback function for event
   */
  addEventListener(eventName, callback) {
    this.revogrid.addEventListener(eventName, callback);
    this.subscriptions[eventName] = callback;
  }
  /**
   * Subscribe to property change in revo-grid component
   * You can return false in callback to prevent default value set
   *
   * @param prop - property name
   * @param callback - callback function
   * @param immediate - trigger callback immediately with current value
   */
  watch(prop, callback, { immediate } = { immediate: false }) {
    const nativeValueDesc = Object.getOwnPropertyDescriptor(this.revogrid, prop) || Object.getOwnPropertyDescriptor(this.revogrid.constructor.prototype, prop);
    Object.defineProperty(this.revogrid, prop, {
      set(val) {
        var _a;
        const keepDefault = callback(val);
        if (keepDefault === false) {
          return;
        }
        return (_a = nativeValueDesc === null || nativeValueDesc === void 0 ? void 0 : nativeValueDesc.set) === null || _a === void 0 ? void 0 : _a.call(this, val);
      },
      get() {
        var _a;
        return (_a = nativeValueDesc === null || nativeValueDesc === void 0 ? void 0 : nativeValueDesc.get) === null || _a === void 0 ? void 0 : _a.call(this);
      }
    });
    if (immediate) {
      callback(nativeValueDesc === null || nativeValueDesc === void 0 ? void 0 : nativeValueDesc.value);
    }
  }
  /**
   * Remove event listener
   * @param eventName
   */
  removeEventListener(eventName) {
    this.revogrid.removeEventListener(eventName, this.subscriptions[eventName]);
    delete this.subscriptions[eventName];
  }
  /**
   * Emit event from revo-grid component
   * Event can be cancelled by calling event.preventDefault() in callback
   */
  emit(eventName, detail) {
    const event = new CustomEvent(eventName, { detail, cancelable: true });
    this.revogrid.dispatchEvent(event);
    return event;
  }
  /**
   * Clear all subscriptions
   */
  clearSubscriptions() {
    for (let type in this.subscriptions) {
      this.removeEventListener(type);
    }
  }
  /**
   * Destroy plugin and clear all subscriptions
   */
  destroy() {
    this.clearSubscriptions();
  }
};
function arrayEach(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
function castFunction(value) {
  return typeof value == "function" ? value : identity;
}
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}
var LETTER_BLOCK_SIZE = 7;
var AutoSizeColumnPlugin = class extends BasePlugin {
  constructor(revogrid, providers, config) {
    super(revogrid, providers);
    this.providers = providers;
    this.config = config;
    this.autoSizeColumns = null;
    this.dataResolve = null;
    this.dataReject = null;
    this.letterBlockSize = (config === null || config === void 0 ? void 0 : config.letterBlockSize) || LETTER_BLOCK_SIZE;
    if (config === null || config === void 0 ? void 0 : config.preciseSize) {
      this.precsizeCalculationArea = this.initiatePresizeElement();
      revogrid.appendChild(this.precsizeCalculationArea);
    }
    const aftersourceset = ({ detail: { source } }) => {
      this.setSource(source);
    };
    const beforecolumnsset = ({ detail: { columns } }) => {
      this.columnSet(columns);
    };
    this.addEventListener("beforecolumnsset", beforecolumnsset);
    switch (config === null || config === void 0 ? void 0 : config.mode) {
      case "autoSizeOnTextOverlap":
        this.addEventListener("aftersourceset", aftersourceset);
        this.addEventListener("afteredit", ({ detail }) => {
          this.afteredit(detail);
        });
        break;
      case "autoSizeAll":
        this.addEventListener("aftersourceset", aftersourceset);
        this.addEventListener("afteredit", ({ detail }) => {
          this.afterEditAll(detail);
        });
        break;
      default:
        this.addEventListener("headerdblclick", ({ detail }) => {
          const type = getColumnType(detail.column);
          const size2 = this.getColumnSize(detail.index, type);
          if (size2) {
            this.providers.dimension.setCustomSizes(type, {
              [detail.index]: size2
            }, true);
          }
        });
        break;
    }
  }
  async setSource(source) {
    let autoSize = this.autoSizeColumns;
    if (this.dataReject) {
      this.dataReject();
      this.clearPromise();
    }
    if (!autoSize) {
      const request = new Promise((resolve, reject) => {
        this.dataResolve = resolve;
        this.dataReject = reject;
      });
      try {
        autoSize = await request;
      } catch (e) {
        return;
      }
    }
    forEach(autoSize, (_v, type) => {
      const sizes = {};
      forEach(autoSize[type], (rgCol) => {
        rgCol.size = sizes[rgCol.index] = source.reduce((prev, rgRow) => Math.max(prev, this.getLength(rgRow[rgCol.prop])), this.getLength(rgCol.name || ""));
      });
      this.providers.dimension.setCustomSizes(type, sizes, true);
    });
  }
  getLength(len) {
    var _a;
    const padding = 15;
    if (!len) {
      return 0;
    }
    try {
      const str = len.toString();
      if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.preciseSize) {
        this.precsizeCalculationArea.innerText = str;
        return this.precsizeCalculationArea.scrollWidth + padding * 2;
      }
      return str.length * this.letterBlockSize + padding * 2;
    } catch (e) {
      return 0;
    }
  }
  afteredit(e) {
    let data;
    if (this.isRangeEdit(e)) {
      data = e.data;
    } else {
      data = { 0: { [e.prop]: e.val } };
    }
    forEach(this.autoSizeColumns, (columns, type) => {
      const sizes = {};
      forEach(columns, (rgCol) => {
        var _a;
        const size2 = reduce(data, (prev, rgRow) => {
          if (typeof rgRow[rgCol.prop] === "undefined") {
            return prev;
          }
          return Math.max(prev || 0, this.getLength(rgRow[rgCol.prop]));
        }, void 0);
        if (size2 && ((_a = rgCol.size) !== null && _a !== void 0 ? _a : 0) < size2) {
          rgCol.size = sizes[rgCol.index] = size2;
        }
      });
      this.providers.dimension.setCustomSizes(type, sizes, true);
    });
  }
  afterEditAll(e) {
    const props = {};
    if (this.isRangeEdit(e)) {
      forEach(e.data, (r) => forEach(r, (_v, p) => props[p] = true));
    } else {
      props[e.prop] = true;
    }
    forEach(this.autoSizeColumns, (columns, type) => {
      const sizes = {};
      forEach(columns, (rgCol) => {
        if (props[rgCol.prop]) {
          const size2 = this.getColumnSize(rgCol.index, type);
          if (size2) {
            sizes[rgCol.index] = size2;
          }
        }
      });
      this.providers.dimension.setCustomSizes(type, sizes, true);
    });
  }
  getColumnSize(index, type) {
    var _a, _b;
    const rgCol = (_b = (_a = this.autoSizeColumns) === null || _a === void 0 ? void 0 : _a[type]) === null || _b === void 0 ? void 0 : _b[index];
    if (!rgCol) {
      return 0;
    }
    return reduce(this.providers.data.stores, (r, s) => {
      const perStore = reduce(s.store.get("items"), (prev, _row, i) => {
        const item = getSourceItem(s.store, i);
        return Math.max(prev || 0, this.getLength(item === null || item === void 0 ? void 0 : item[rgCol.prop]));
      }, 0);
      return Math.max(r, perStore);
    }, rgCol.size || 0);
  }
  columnSet(columns) {
    var _a;
    for (let t of columnTypes) {
      const type = t;
      const cols = columns[type];
      for (let i in cols) {
        if (cols[i].autoSize || ((_a = this.config) === null || _a === void 0 ? void 0 : _a.allColumns)) {
          if (!this.autoSizeColumns) {
            this.autoSizeColumns = {};
          }
          if (!this.autoSizeColumns[type]) {
            this.autoSizeColumns[type] = {};
          }
          this.autoSizeColumns[type][i] = Object.assign(Object.assign({}, cols[i]), { index: parseInt(i, 10) });
        }
      }
    }
    if (this.dataResolve) {
      this.dataResolve(this.autoSizeColumns || {});
      this.clearPromise();
    }
  }
  clearPromise() {
    this.dataResolve = null;
    this.dataReject = null;
  }
  isRangeEdit(e) {
    return !!e.data;
  }
  initiatePresizeElement() {
    var _a;
    const styleForFontTest = {
      position: "absolute",
      fontSize: "14px",
      height: "0",
      width: "0",
      whiteSpace: "nowrap",
      top: "0",
      overflowX: "scroll",
      display: "block"
    };
    const el = document.createElement("div");
    for (let s in styleForFontTest) {
      el.style[s] = (_a = styleForFontTest[s]) !== null && _a !== void 0 ? _a : "";
    }
    el.classList.add("revo-test-container");
    return el;
  }
  destroy() {
    var _a;
    super.destroy();
    (_a = this.precsizeCalculationArea) === null || _a === void 0 ? void 0 : _a.remove();
  }
};
var StretchColumn = class extends BasePlugin {
  constructor(revogrid, providers) {
    super(revogrid, providers);
    this.providers = providers;
    this.stretchedColumn = null;
    this.scrollSize = getScrollbarSize(document);
    const beforecolumnapplied = ({ detail: { columns } }) => this.applyStretch(columns);
    this.addEventListener("beforecolumnapplied", beforecolumnapplied);
  }
  setScroll({ type, hasScroll }) {
    var _a;
    if (type === "rgRow" && this.stretchedColumn && ((_a = this.stretchedColumn) === null || _a === void 0 ? void 0 : _a.initialSize) === this.stretchedColumn.size) {
      if (hasScroll) {
        this.stretchedColumn.size -= this.scrollSize;
        this.apply();
        this.dropChanges();
      }
    }
  }
  activateChanges() {
    const setScroll = ({ detail }) => this.setScroll(detail);
    this.addEventListener("scrollchange", setScroll);
  }
  dropChanges() {
    this.stretchedColumn = null;
    this.removeEventListener("scrollchange");
  }
  apply() {
    if (!this.stretchedColumn) {
      return;
    }
    const type = "rgCol";
    const sizes = this.providers.dimension.stores[type].store.get("sizes");
    this.providers.dimension.setCustomSizes(type, Object.assign(Object.assign({}, sizes), { [this.stretchedColumn.index]: this.stretchedColumn.size }), true);
  }
  /**
   * Apply stretch changes
   */
  applyStretch(columns) {
    this.dropChanges();
    let sizeDifference = this.revogrid.clientWidth - 1;
    forEach(columns, (_, type) => {
      const realSize = this.providers.dimension.stores[type].store.get("realSize");
      sizeDifference -= realSize;
    });
    if (this.revogrid.rowHeaders) {
      const itemsLength = this.providers.data.stores.rgRow.store.get("source").length;
      const header = this.revogrid.rowHeaders;
      const rowHeaderSize = calculateRowHeaderSize(itemsLength, typeof header === "object" ? header : void 0);
      if (rowHeaderSize) {
        sizeDifference -= rowHeaderSize;
      }
    }
    if (sizeDifference > 0) {
      const index = columns.rgCol.length - 1;
      const last = columns.rgCol[index];
      const colSize = (last === null || last === void 0 ? void 0 : last.size) || this.revogrid.colSize || 0;
      const size2 = sizeDifference + colSize - 1;
      if (last && !last.autoSize && colSize < size2) {
        this.stretchedColumn = {
          initialSize: size2,
          index,
          size: size2
        };
        this.apply();
        this.activateChanges();
      }
    }
  }
};
function isStretchPlugin(plugin) {
  return !!plugin.applyStretch;
}
function baseClamp(number, lower, upper) {
  if (number === number) {
    {
      number = number <= upper ? number : upper;
    }
    {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var MAX_ARRAY_LENGTH = 4294967295;
function toLength(value) {
  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
}
function baseFill(array, value, start, end) {
  var length = array.length;
  start = toInteger(start);
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end === void 0 || end > length ? length : toInteger(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : toLength(end);
  while (start < end) {
    array[start++] = value;
  }
  return array;
}
function fill(array, value, start, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  return baseFill(array, value, start, end);
}
var INITIAL = {
  mime: "text/csv",
  fileKind: "csv",
  // BOM signature
  bom: true,
  columnDelimiter: ",",
  rowDelimiter: "\r\n",
  encoding: ""
};
var CARRIAGE_RETURN = String.fromCharCode(13);
var LINE_FEED = String.fromCharCode(10);
var DOUBLE_QT = String.fromCharCode(34);
var NO_BREAK_SPACE = String.fromCharCode(65279);
var escapeRegex = new RegExp('"', "g");
var ExportCsv = class {
  constructor(options = {}) {
    this.options = Object.assign(Object.assign({}, INITIAL), options);
  }
  doExport({ data, headers, props }) {
    let result = this.options.bom ? NO_BREAK_SPACE : "";
    if ((headers === null || headers === void 0 ? void 0 : headers.length) > 0) {
      headers.forEach((header) => {
        if (!header.length) {
          return;
        }
        result += this.prepareHeader(header, this.options.columnDelimiter);
        result += this.options.rowDelimiter;
      });
    }
    data.forEach((rgRow, index) => {
      if (index > 0) {
        result += this.options.rowDelimiter;
      }
      if (isGrouping(rgRow)) {
        result += this.parseCell(getGroupingName(rgRow), this.options.columnDelimiter);
        return;
      }
      result += props.map((p) => this.parseCell(rgRow[p], this.options.columnDelimiter)).join(this.options.columnDelimiter);
    });
    return result;
  }
  prepareHeader(columnHeaders, columnDelimiter) {
    let result = "";
    const newColumnHeaders = columnHeaders.map((v) => this.parseCell(v, columnDelimiter, true));
    result += newColumnHeaders.join(columnDelimiter);
    return result;
  }
  parseCell(value, columnDelimiter, force = false) {
    let escape = value;
    if (typeof value !== "string") {
      escape = JSON.stringify(value);
    }
    const toEscape = [CARRIAGE_RETURN, DOUBLE_QT, LINE_FEED, columnDelimiter];
    if (typeof escape === "undefined") {
      return "";
    }
    if (escape !== "" && (force || toEscape.some((i) => escape.indexOf(i) >= 0))) {
      return `"${escape.replace(escapeRegex, '""')}"`;
    }
    return escape;
  }
};
var ExportTypes;
(function(ExportTypes2) {
  ExportTypes2["csv"] = "csv";
})(ExportTypes || (ExportTypes = {}));
var ExportFilePlugin = class extends BasePlugin {
  /** Exports string */
  async exportString(options = {}, t = ExportTypes.csv) {
    const data = await this.beforeexport();
    if (!data) {
      return null;
    }
    return this.formatter(t, options).doExport(data);
  }
  /** Exports Blob */
  async exportBlob(options = {}, t = ExportTypes.csv) {
    return await this.getBlob(this.formatter(t, options));
  }
  /** Export file */
  async exportFile(options = {}, t = ExportTypes.csv) {
    const formatter = this.formatter(t, options);
    const URL = window.URL || window.webkitURL;
    const a = document.createElement("a");
    const { filename, fileKind } = formatter.options;
    const name = `${filename}.${fileKind}`;
    const blob = await this.getBlob(formatter);
    const url = blob ? URL.createObjectURL(blob) : "";
    a.style.display = "none";
    a.setAttribute("href", url);
    a.setAttribute("download", name);
    this.revogrid.appendChild(a);
    a.dispatchEvent(new MouseEvent("click"));
    this.revogrid.removeChild(a);
    await timeout(120);
    URL.revokeObjectURL(url);
  }
  /** Blob object */
  async getBlob(formatter) {
    const type = `${formatter.options.mime};charset=${formatter.options.encoding}`;
    if (typeof Blob !== "undefined") {
      const data = await this.beforeexport();
      if (!data) {
        return null;
      }
      return new Blob([formatter.doExport(data)], { type });
    }
    return null;
  }
  // before event
  async beforeexport() {
    let data = await this.getData();
    const event = this.emit("beforeexport", { data });
    if (event.defaultPrevented) {
      return null;
    }
    return event.detail.data;
  }
  async getData() {
    const data = await this.getSource();
    const colSource = [];
    const colPromises = [];
    columnTypes.forEach((t, i) => {
      colPromises.push(this.getColPerSource(t).then((s) => colSource[i] = s));
    });
    await Promise.all(colPromises);
    const columns = {
      headers: [],
      props: []
    };
    for (let source of colSource) {
      source.headers.forEach((h2, i) => {
        if (!columns.headers[i]) {
          columns.headers[i] = [];
        }
        columns.headers[i].push(...h2);
      });
      columns.props.push(...source.props);
    }
    return Object.assign({ data }, columns);
  }
  async getColPerSource(t) {
    const store = await this.revogrid.getColumnStore(t);
    const source = store.get("source");
    const virtualIndexes = store.get("items");
    const depth = store.get("groupingDepth");
    const groups = store.get("groups");
    const colNames = [];
    const colProps = [];
    virtualIndexes.forEach((v) => {
      const prop = source[v].prop;
      colNames.push(source[v].name || "");
      colProps.push(prop);
    });
    const rows = this.getGroupHeaders(depth, groups, virtualIndexes);
    rows.push(colNames);
    return {
      headers: rows,
      props: colProps
    };
  }
  getGroupHeaders(depth, groups, items) {
    const rows = [];
    const template = fill(new Array(items.length), "");
    for (let d = 0; d < depth; d++) {
      const rgRow = [...template];
      rows.push(rgRow);
      if (!groups[d]) {
        continue;
      }
      const levelGroups = groups[d];
      levelGroups.forEach((group) => {
        const minIndex = group.indexes[0];
        if (typeof minIndex === "number") {
          rgRow[minIndex] = group.name;
        }
      });
    }
    return rows;
  }
  async getSource() {
    const data = [];
    const promisesData = [];
    rowTypes.forEach((t) => {
      const dataPart = [];
      data.push(dataPart);
      const promise = this.revogrid.getVisibleSource(t).then((d) => dataPart.push(...d));
      promisesData.push(promise);
    });
    await Promise.all(promisesData);
    return data.reduce((r, v) => {
      r.push(...v);
      return r;
    }, []);
  }
  // get correct class for future multiple types support
  formatter(type, options = {}) {
    switch (type) {
      case ExportTypes.csv:
        return new ExportCsv(options);
      default:
        throw new Error("Unknown format");
    }
  }
};
var eq = (value, extra) => {
  if (typeof value === "undefined" || value === null && !extra) {
    return true;
  }
  if (typeof value !== "string") {
    value = JSON.stringify(value);
  }
  const filterVal = extra === null || extra === void 0 ? void 0 : extra.toString().toLocaleLowerCase();
  if ((filterVal === null || filterVal === void 0 ? void 0 : filterVal.length) === 0) {
    return true;
  }
  return value.toLocaleLowerCase() === filterVal;
};
var notEq = (value, extra) => !eq(value, extra);
notEq.extra = "input";
eq.extra = "input";
var gtThan = function(value, extra) {
  let conditionValue;
  if (typeof value === "number" && typeof extra !== "undefined" && extra !== null) {
    conditionValue = parseFloat(extra === null || extra === void 0 ? void 0 : extra.toString());
    return value > conditionValue;
  }
  return false;
};
gtThan.extra = "input";
var gtThanEq = function(value, extra) {
  return eq(value, extra) || gtThan(value, extra);
};
gtThanEq.extra = "input";
var lt = function(value, extra) {
  let conditionValue;
  if (typeof value === "number" && typeof extra !== "undefined" && extra !== null) {
    conditionValue = parseFloat(extra.toString());
    return value < conditionValue;
  } else {
    return false;
  }
};
lt.extra = "input";
var lsEq = function(value, extra) {
  return eq(value, extra) || lt(value, extra);
};
lsEq.extra = "input";
var set = (value) => !(value === "" || value === null || value === void 0);
var notSet = (value) => !set(value);
var beginsWith = (value, extra) => {
  if (!value) {
    return false;
  }
  if (!extra) {
    return true;
  }
  if (typeof value !== "string") {
    value = JSON.stringify(value);
  }
  if (typeof extra !== "string") {
    extra = JSON.stringify(extra);
  }
  return value.toLocaleLowerCase().indexOf(extra.toLocaleLowerCase()) === 0;
};
beginsWith.extra = "input";
var contains = (value, extra) => {
  if (!extra) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (extra) {
    if (typeof value !== "string") {
      value = JSON.stringify(value);
    }
    return value.toLocaleLowerCase().indexOf(extra.toString().toLowerCase()) > -1;
  }
  return true;
};
var notContains = (value, extra) => {
  return !contains(value, extra);
};
notContains.extra = "input";
contains.extra = "input";
var filterCoreFunctionsIndexedByType = {
  none: () => true,
  empty: notSet,
  notEmpty: set,
  eq,
  notEq,
  begins: beginsWith,
  contains,
  notContains,
  eqN: eq,
  neqN: notEq,
  gt: gtThan,
  gte: gtThanEq,
  lt,
  lte: lsEq
};
var filterTypes = {
  string: ["notEmpty", "empty", "eq", "notEq", "begins", "contains", "notContains"],
  number: ["notEmpty", "empty", "eqN", "neqN", "gt", "gte", "lt", "lte"]
};
var filterNames = {
  none: "None",
  empty: "Not set",
  notEmpty: "Set",
  eq: "Equal",
  notEq: "Not equal",
  begins: "Begins with",
  contains: "Contains",
  notContains: "Does not contain",
  eqN: "=",
  neqN: "!=",
  gt: ">",
  gte: ">=",
  lt: "<",
  lte: "<="
};
var FILTER_TRIMMED_TYPE = "filter";
var FILTER_CONFIG_CHANGED_EVENT = "filterconfigchanged";
var FILTE_PANEL = "revogr-filter-panel";
var FilterPlugin = class extends BasePlugin {
  constructor(revogrid, providers, config) {
    var _a;
    super(revogrid, providers);
    this.revogrid = revogrid;
    this.config = config;
    this.filterCollection = {};
    this.multiFilterItems = {};
    this.filterByType = Object.assign({}, filterTypes);
    this.filterNameIndexByType = Object.assign({}, filterNames);
    this.filterFunctionsIndexedByType = Object.assign({}, filterCoreFunctionsIndexedByType);
    this.filterProp = FILTER_PROP;
    if (config) {
      this.initConfig(config);
    }
    const existingNodes = this.revogrid.registerVNode.filter((n) => typeof n === "object" && n.$tag$ !== FILTE_PANEL);
    this.revogrid.registerVNode = [
      ...existingNodes,
      h(
        "revogr-filter-panel",
        { filterNames: this.filterNameIndexByType, filterEntities: this.filterFunctionsIndexedByType, filterCaptions: (_a = config === null || config === void 0 ? void 0 : config.localization) === null || _a === void 0 ? void 0 : _a.captions, onFilterChange: (e) => this.onFilterChange(e.detail), onResetChange: (e) => this.onFilterReset(e.detail), disableDynamicFiltering: config === null || config === void 0 ? void 0 : config.disableDynamicFiltering, closeOnOutsideClick: config === null || config === void 0 ? void 0 : config.closeFilterPanelOnOutsideClick, ref: (e) => this.pop = e },
        " ",
        this.extraContent()
      )
    ];
    const aftersourceset = async () => {
      const filterCollectionProps = Object.keys(this.filterCollection);
      if (filterCollectionProps.length > 0) {
        filterCollectionProps.forEach((prop, index) => {
          if (!this.multiFilterItems[prop]) {
            this.multiFilterItems[prop] = [
              {
                id: index,
                type: this.filterCollection[prop].type,
                value: this.filterCollection[prop].value,
                relation: "and"
              }
            ];
          }
        });
      }
      if (Object.keys(this.multiFilterItems).length === 0) {
        return;
      }
      await this.runFiltering(this.multiFilterItems);
    };
    this.addEventListener("headerclick", (e) => this.headerclick(e));
    this.addEventListener(FILTER_CONFIG_CHANGED_EVENT, ({ detail }) => {
      if (!detail || typeof detail === "object" && (!detail.multiFilterItems || !Object.keys(detail.multiFilterItems).length)) {
        this.clearFiltering();
        return;
      }
      if (typeof detail === "object") {
        this.initConfig(detail);
      }
      aftersourceset();
    });
    this.addEventListener("aftersourceset", aftersourceset);
    this.addEventListener("filter", ({ detail }) => this.onFilterChange(detail));
  }
  beforeshow(_) {
  }
  extraContent() {
    return null;
  }
  initConfig(config) {
    if (config.multiFilterItems) {
      this.multiFilterItems = Object.assign({}, config.multiFilterItems);
    } else {
      this.multiFilterItems = {};
    }
    if (config.customFilters) {
      for (let customFilterType in config.customFilters) {
        const cFilter = config.customFilters[customFilterType];
        if (!this.filterByType[cFilter.columnFilterType]) {
          this.filterByType[cFilter.columnFilterType] = [];
        }
        this.filterByType[cFilter.columnFilterType].push(customFilterType);
        this.filterFunctionsIndexedByType[customFilterType] = cFilter.func;
        this.filterNameIndexByType[customFilterType] = cFilter.name;
      }
    }
    if (config.filterProp) {
      this.filterProp = config.filterProp;
    }
    const cfgInlcude = config.include;
    if (cfgInlcude) {
      const filters = {};
      for (let t in this.filterByType) {
        const newTypes = this.filterByType[t].filter((f) => cfgInlcude.indexOf(f) > -1);
        if (newTypes.length) {
          filters[t] = newTypes;
        }
      }
      if (Object.keys(filters).length > 0) {
        this.filterByType = filters;
      }
    }
    if (config.collection) {
      const filtersWithFilterFunctionPresent = Object.entries(config.collection).filter(([, item]) => this.filterFunctionsIndexedByType[item.type]);
      this.filterCollection = Object.fromEntries(filtersWithFilterFunctionPresent);
    } else {
      this.filterCollection = {};
    }
    if (config.localization) {
      if (config.localization.filterNames) {
        Object.entries(config.localization.filterNames).forEach(([k, v]) => {
          if (this.filterNameIndexByType[k] != void 0) {
            this.filterNameIndexByType[k] = v;
          }
        });
      }
    }
  }
  async headerclick(e) {
    var _a, _b;
    const el = (_a = e.detail.originalEvent) === null || _a === void 0 ? void 0 : _a.target;
    if (!isFilterBtn(el)) {
      return;
    }
    e.preventDefault();
    if (!this.pop) {
      return;
    }
    const gridPos = this.revogrid.getBoundingClientRect();
    const buttonPos = el.getBoundingClientRect();
    const prop = e.detail.prop;
    const data = Object.assign(Object.assign(Object.assign({}, e.detail), this.filterCollection[prop]), { x: buttonPos.x - gridPos.x, y: buttonPos.y - gridPos.y + buttonPos.height, autoCorrect: true, filterTypes: this.getColumnFilter(e.detail.filter), filterItems: this.multiFilterItems, extraContent: this.extraHyperContent });
    (_b = this.beforeshow) === null || _b === void 0 ? void 0 : _b.call(this, data);
    this.pop.show(data);
  }
  getColumnFilter(type) {
    let filterType = "string";
    if (!type) {
      return { [filterType]: this.filterByType[filterType] };
    }
    if (this.isValidType(type)) {
      filterType = type;
    } else if (typeof type === "object" && type.length) {
      return type.reduce((r, multiType) => {
        if (this.isValidType(multiType)) {
          r[multiType] = this.filterByType[multiType];
        }
        return r;
      }, {});
    }
    return { [filterType]: this.filterByType[filterType] };
  }
  isValidType(type) {
    return !!(typeof type === "string" && this.filterByType[type]);
  }
  /**
   * Called on internal component change
   */
  async onFilterChange(filterItems) {
    this.multiFilterItems = filterItems;
    this.runFiltering(this.multiFilterItems);
  }
  onFilterReset(prop) {
    delete this.multiFilterItems[prop !== null && prop !== void 0 ? prop : ""];
    this.onFilterChange(this.multiFilterItems);
  }
  /**
   * Triggers grid filtering
   */
  async doFiltering(collection, source, columns, filterItems) {
    const columnsToUpdate = [];
    const columnByProp = {};
    columns.forEach((rgCol) => {
      const column = Object.assign({}, rgCol);
      const hasFilter = filterItems[column.prop];
      columnByProp[column.prop] = column;
      if (column[this.filterProp] && !hasFilter) {
        delete column[this.filterProp];
        columnsToUpdate.push(column);
      }
      if (!column[this.filterProp] && hasFilter) {
        columnsToUpdate.push(column);
        column[this.filterProp] = true;
      }
    });
    const itemsToTrim = this.getRowFilter(source, filterItems, columnByProp);
    const { defaultPrevented, detail } = this.emit("beforefiltertrimmed", {
      collection,
      itemsToFilter: itemsToTrim,
      source,
      filterItems
    });
    if (defaultPrevented) {
      return;
    }
    this.providers.data.setTrimmed({ [FILTER_TRIMMED_TYPE]: detail.itemsToFilter });
    this.providers.column.updateColumns(columnsToUpdate);
    this.emit("afterfilterapply", {
      multiFilterItems: filterItems,
      source,
      collection
    });
  }
  async clearFiltering() {
    this.multiFilterItems = {};
    await this.runFiltering(this.multiFilterItems);
  }
  async runFiltering(multiFilterItems) {
    const collection = {};
    const filterProps = Object.keys(multiFilterItems);
    for (const prop of filterProps) {
      if (multiFilterItems[prop].length > 0) {
        const firstFilterItem = multiFilterItems[prop][0];
        collection[prop] = {
          type: firstFilterItem.type,
          value: firstFilterItem.value
        };
      }
    }
    this.filterCollection = collection;
    const columns = this.providers.column.getColumns();
    const source = this.providers.data.stores["rgRow"].store.get("source");
    const { defaultPrevented, detail } = this.emit("beforefilterapply", {
      collection: this.filterCollection,
      source,
      columns,
      filterItems: this.multiFilterItems
    });
    if (defaultPrevented) {
      return;
    }
    this.doFiltering(detail.collection, detail.source, detail.columns, detail.filterItems);
  }
  /**
   * Get trimmed rows based on filter
   */
  getRowFilter(rows, filterItems, columnByProp) {
    const propKeys = Object.keys(filterItems);
    const trimmed = {};
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      for (const prop of propKeys) {
        if (this.shouldTrimRow(filterItems[prop], prop, columnByProp[prop], rows[rowIndex])) {
          trimmed[rowIndex] = true;
        }
      }
    }
    return trimmed;
  }
  shouldTrimRow(propFilters, prop, column, model = {}) {
    let propFilterSatisfiedCount = 0;
    let lastFilterResults = [];
    for (const [filterIndex, filterData] of propFilters.entries()) {
      const filterFunc = this.filterFunctionsIndexedByType[filterData.type];
      const value = column ? getCellDataParsed(model, column) : model[prop];
      if (filterData.relation === "or") {
        lastFilterResults = [];
        if (filterFunc(value, filterData.value)) {
          continue;
        }
        propFilterSatisfiedCount++;
      } else {
        lastFilterResults.push(!filterFunc(value, filterData.value));
        if (isFinalAndFilter(filterIndex, propFilters)) {
          if (allAndConditionsSatisfied(lastFilterResults)) {
            lastFilterResults = [];
            continue;
          }
          propFilterSatisfiedCount += lastFilterResults.length;
          lastFilterResults = [];
        }
      }
    }
    return propFilterSatisfiedCount === propFilters.length;
  }
};
function isFinalAndFilter(index, filters) {
  const nextFilter = filters[index + 1];
  return !nextFilter || !!nextFilter.relation && nextFilter.relation !== "and";
}
function allAndConditionsSatisfied(pendingResults) {
  return !pendingResults.includes(true);
}
var stringTag = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}
var asciiSize = baseProperty("length");
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}
function stringSize(string) {
  return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
}
var mapTag = "[object Map]";
var setTag = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }
  var tag = getTag(collection);
  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }
  return baseKeys(collection).length;
}
function sortIndexByItems(indexes, source, sortingFunc = {}) {
  if (Object.entries(sortingFunc).length === 0) {
    return [...Array(indexes.length).keys()];
  }
  return indexes.sort((a, b) => {
    const itemA = source[a];
    const itemB = source[b];
    for (const [prop, cmp] of Object.entries(sortingFunc)) {
      if (isGrouping(itemA)) {
        if (itemA["__rvgr-prop"] !== prop) {
          return 0;
        }
      }
      if (isGrouping(itemB)) {
        if (itemB["__rvgr-prop"] !== prop) {
          return 0;
        }
      }
      const sorted = cmp === null || cmp === void 0 ? void 0 : cmp(prop, itemA, itemB);
      if (sorted) {
        return sorted;
      }
    }
    return 0;
  });
}
function defaultCellCompare(prop, a, b) {
  const aRaw = this.column ? getCellRaw(a, this.column) : a === null || a === void 0 ? void 0 : a[prop];
  const bRaw = this.column ? getCellRaw(b, this.column) : b === null || b === void 0 ? void 0 : b[prop];
  const av = typeof aRaw === "number" ? aRaw : aRaw === null || aRaw === void 0 ? void 0 : aRaw.toString().toLowerCase();
  const bv = typeof bRaw === "number" ? bRaw : bRaw === null || bRaw === void 0 ? void 0 : bRaw.toString().toLowerCase();
  if (av === bv) {
    return 0;
  }
  if (av > bv) {
    return 1;
  }
  return -1;
}
function descCellCompare(cmp) {
  return (prop, a, b) => {
    return -1 * cmp(prop, a, b);
  };
}
function getNextOrder(currentOrder) {
  switch (currentOrder) {
    case void 0:
      return "asc";
    case "asc":
      return "desc";
    case "desc":
      return void 0;
  }
}
function getComparer(column, order) {
  var _a;
  const cellCmp = ((_a = column === null || column === void 0 ? void 0 : column.cellCompare) === null || _a === void 0 ? void 0 : _a.bind({ order })) || (defaultCellCompare === null || defaultCellCompare === void 0 ? void 0 : defaultCellCompare.bind({ column, order }));
  if (order == "asc") {
    return cellCmp;
  }
  if (order == "desc") {
    return descCellCompare(cellCmp);
  }
  return void 0;
}
var SortingPlugin = class extends BasePlugin {
  constructor(revogrid, providers, config) {
    super(revogrid, providers);
    this.revogrid = revogrid;
    this.sortingPromise = null;
    this.postponeSort = debounce((order, comparison, ignoreViewportUpdate) => this.runSorting(order, comparison, ignoreViewportUpdate), 50);
    const setConfig = (cfg) => {
      var _a;
      if (cfg) {
        const sortingFunc = {};
        const order = {};
        (_a = cfg.columns) === null || _a === void 0 ? void 0 : _a.forEach((col) => {
          sortingFunc[col.prop] = getComparer(col, col.order);
          order[col.prop] = col.order;
        });
        if (cfg.additive) {
          this.sorting = Object.assign(Object.assign({}, this.sorting), order);
          this.sortingFunc = Object.assign(Object.assign({}, this.sortingFunc), sortingFunc);
        } else {
          this.sorting = order;
          this.sortingFunc = sortingFunc;
        }
      }
    };
    setConfig(config);
    this.addEventListener("sortingconfigchanged", ({ detail }) => {
      config = detail;
      setConfig(detail);
      this.startSorting(this.sorting, this.sortingFunc);
    });
    this.addEventListener("beforeheaderrender", ({ detail }) => {
      var _a;
      const { data: column } = detail;
      if (column.sortable) {
        detail.data = Object.assign(Object.assign({}, column), { order: (_a = this.sorting) === null || _a === void 0 ? void 0 : _a[column.prop] });
      }
    });
    this.addEventListener("beforeanysource", ({ detail: { type } }) => {
      if (!!this.sorting && this.sortingFunc) {
        const event = this.emit("beforesourcesortingapply", { type, sorting: this.sorting });
        if (event.defaultPrevented) {
          return;
        }
        this.startSorting(this.sorting, this.sortingFunc);
      }
    });
    this.addEventListener("aftercolumnsset", ({ detail: { order } }) => {
      if (config) {
        return;
      }
      const columns = this.providers.column.getColumns();
      const sortingFunc = {};
      for (let prop in order) {
        const cmp = getComparer(getColumnByProp(columns, prop), order[prop]);
        sortingFunc[prop] = cmp;
      }
      this.sorting = order;
      this.sortingFunc = order && sortingFunc;
    });
    this.addEventListener("beforeheaderclick", (e) => {
      var _a, _b, _c, _d;
      if (e.defaultPrevented) {
        return;
      }
      if (!((_b = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.column) === null || _b === void 0 ? void 0 : _b.sortable)) {
        return;
      }
      this.headerclick(e.detail.column, (_d = (_c = e.detail) === null || _c === void 0 ? void 0 : _c.originalEvent) === null || _d === void 0 ? void 0 : _d.shiftKey);
    });
  }
  /**
   * Entry point for sorting, waits for all delayes, registers jobs
   */
  startSorting(order, sortingFunc, ignoreViewportUpdate) {
    if (!this.sortingPromise) {
      this.revogrid.jobsBeforeRender.push(new Promise((resolve) => {
        this.sortingPromise = resolve;
      }));
    }
    this.postponeSort(order, sortingFunc, ignoreViewportUpdate);
  }
  /**
   * Apply sorting to data on header click
   * If additive - add to existing sorting, multiple columns can be sorted
   */
  headerclick(column, additive) {
    var _a, _b, _c;
    const columnProp = column.prop;
    let order = getNextOrder((_a = this.sorting) === null || _a === void 0 ? void 0 : _a[columnProp]);
    const beforeEvent = this.emit("beforesorting", { column, order, additive });
    if (beforeEvent.defaultPrevented) {
      return;
    }
    order = beforeEvent.detail.order;
    const beforeApplyEvent = this.emit("beforesortingapply", {
      column: beforeEvent.detail.column,
      order,
      additive
    });
    if (beforeApplyEvent.defaultPrevented) {
      return;
    }
    const cmp = getComparer(beforeApplyEvent.detail.column, beforeApplyEvent.detail.order);
    if (beforeApplyEvent.detail.additive && this.sorting) {
      const sorting = {};
      const sortingFunc = {};
      if (columnProp in sorting && size(sorting) > 1 && order === void 0) {
        delete sorting[columnProp];
        delete sortingFunc[columnProp];
      } else {
        sorting[columnProp] = order;
        sortingFunc[columnProp] = cmp;
      }
      this.sorting = Object.assign(Object.assign({}, this.sorting), sorting);
      this.sortingFunc = Object.assign(Object.assign({}, this.sortingFunc), sortingFunc);
    } else {
      if (order) {
        this.sorting = { [columnProp]: order };
        this.sortingFunc = { [columnProp]: cmp };
      } else {
        (_b = this.sorting) === null || _b === void 0 ? true : delete _b[columnProp];
        (_c = this.sortingFunc) === null || _c === void 0 ? true : delete _c[columnProp];
      }
    }
    this.startSorting(this.sorting, this.sortingFunc);
  }
  runSorting(order, comparison, ignoreViewportUpdate) {
    var _a;
    this.sort(order, comparison, void 0, ignoreViewportUpdate);
    (_a = this.sortingPromise) === null || _a === void 0 ? void 0 : _a.call(this);
    this.sortingPromise = null;
  }
  /**
   * Sort items by sorting function
   * @requires proxyItems applied to row store
   * @requires source applied to row store
   *
   * @param sorting - per column sorting
   * @param data - this.stores['rgRow'].store.get('source')
   */
  sort(sorting, sortingFunc, types = rowTypes, ignoreViewportUpdate = false) {
    if (!Object.keys(sorting || {}).length) {
      for (let type of types) {
        const storeService = this.providers.data.stores[type];
        const source = storeService.store.get("source");
        const proxyItems = storeService.store.get("proxyItems");
        const newItemsOrder = Array.from({ length: source.length }, (_, i) => i);
        this.providers.dimension.updateSizesPositionByNewDataIndexes(type, newItemsOrder, proxyItems);
        storeService.setData({ proxyItems: newItemsOrder, source: [...source] });
      }
    } else {
      for (let type of types) {
        const storeService = this.providers.data.stores[type];
        const source = storeService.store.get("source");
        const proxyItems = storeService.store.get("proxyItems");
        const newItemsOrder = sortIndexByItems([...proxyItems], source, sortingFunc);
        const prevItems = storeService.store.get("items");
        storeService.setData({
          proxyItems: newItemsOrder,
          source: [...source]
        });
        const newItems = storeService.store.get("items");
        if (!ignoreViewportUpdate) {
          this.providers.dimension.updateSizesPositionByNewDataIndexes(type, newItems, prevItems);
        }
      }
    }
    columnTypes.forEach((type) => {
      this.providers.column.dataSources[type].refresh();
    });
    this.emit("aftersortingapply");
  }
};
function doCollapse(pIndex, source) {
  const model = source[pIndex];
  const collapseValue = model[PSEUDO_GROUP_ITEM_VALUE];
  const trimmed = {};
  let i = pIndex + 1;
  const total = source.length;
  while (i < total) {
    const currentModel = source[i];
    if (isGrouping(currentModel)) {
      const currentValue = currentModel[PSEUDO_GROUP_ITEM_VALUE];
      if (!currentValue.length || !currentValue.startsWith(collapseValue + ",")) {
        break;
      }
      currentModel[GROUP_EXPANDED] = false;
    }
    trimmed[i++] = true;
  }
  model[GROUP_EXPANDED] = false;
  return { trimmed };
}
function doExpand(vIndex, source, rowItemsIndexes) {
  const physicalIndex = rowItemsIndexes[vIndex];
  const model = source[physicalIndex];
  const currentGroup = getParsedGroup(model[PSEUDO_GROUP_ITEM_ID]);
  const trimmed = {};
  if (!currentGroup) {
    return { trimmed };
  }
  const groupItems = [];
  model[GROUP_EXPANDED] = true;
  let i = physicalIndex + 1;
  const total = source.length;
  let groupLevelOnly = 0;
  while (i < total) {
    const currentModel = source[i];
    const isGroup = isGrouping(currentModel);
    if (isGroup) {
      if (!isSameGroup(currentGroup, model, currentModel)) {
        break;
      } else if (!groupLevelOnly) {
        groupLevelOnly = currentModel[GROUP_DEPTH];
      }
    }
    if (!groupLevelOnly || isGroup && groupLevelOnly === currentModel[GROUP_DEPTH]) {
      trimmed[i] = false;
      groupItems.push(i);
    }
    i++;
  }
  const result = {
    trimmed
  };
  if (groupItems.length) {
    const items = [...rowItemsIndexes];
    items.splice(vIndex + 1, 0, ...groupItems);
    result.items = items;
  }
  return result;
}
var TRIMMED_GROUPING = "grouping";
function processDoubleConversionTrimmed(initiallyTrimed, firstLevelMap, secondLevelMap) {
  const trimemedOptionsToUpgrade = {};
  for (let type in initiallyTrimed) {
    if (type === TRIMMED_GROUPING) {
      continue;
    }
    const items = initiallyTrimed[type];
    const newItems = {};
    for (let initialIndex in items) {
      let newConversionIndex = firstLevelMap[initialIndex];
      if (secondLevelMap) {
        newConversionIndex = secondLevelMap[newConversionIndex];
      }
      if (items[initialIndex]) {
        newItems[newConversionIndex] = true;
        if (newConversionIndex !== parseInt(initialIndex, 10)) {
          trimemedOptionsToUpgrade[type] = newItems;
        }
      }
    }
  }
  return trimemedOptionsToUpgrade;
}
var GroupingRowPlugin = class extends BasePlugin {
  getStore(type = GROUPING_ROW_TYPE) {
    return this.providers.data.stores[type].store;
  }
  constructor(revogrid, providers) {
    super(revogrid, providers);
  }
  // befoce cell focus
  onFocus(e) {
    if (isGrouping(e.detail.model)) {
      e.preventDefault();
    }
  }
  // expand event triggered
  onExpand({ virtualIndex }) {
    const { source } = getSource(this.getStore().get("source"), this.getStore().get("proxyItems"));
    let newTrimmed = this.getStore().get("trimmed")[TRIMMED_GROUPING];
    let i = getPhysical(this.getStore(), virtualIndex);
    const isExpanded = getExpanded(source[i]);
    if (!isExpanded) {
      const { trimmed, items } = doExpand(virtualIndex, source, this.getStore().get("items"));
      newTrimmed = Object.assign(Object.assign({}, newTrimmed), trimmed);
      if (items) {
        setItems(this.getStore(), items);
      }
    } else {
      const { trimmed } = doCollapse(i, source);
      newTrimmed = Object.assign(Object.assign({}, newTrimmed), trimmed);
      this.revogrid.clearFocus();
    }
    this.getStore().set("source", source);
    this.revogrid.addTrimmed(newTrimmed, TRIMMED_GROUPING);
  }
  setColumnGrouping(cols) {
    if (cols === null || cols === void 0 ? void 0 : cols.length) {
      cols[0][PSEUDO_GROUP_COLUMN] = true;
      return true;
    }
    return false;
  }
  setColumns({ columns }) {
    for (let type of columnTypes) {
      if (this.setColumnGrouping(columns[type])) {
        break;
      }
    }
  }
  // evaluate drag between groups
  onDrag(e) {
    const { from, to } = e.detail;
    const isDown = to - from >= 0;
    const { source } = getSource(this.getStore().get("source"), this.getStore().get("proxyItems"));
    const items = this.getStore().get("items");
    let i = isDown ? from : to;
    const end = isDown ? to : from;
    for (; i < end; i++) {
      const model = source[items[i]];
      const isGroup = isGrouping(model);
      if (isGroup) {
        e.preventDefault();
        return;
      }
    }
  }
  beforeTrimmedApply(trimmed, type) {
    if (type === FILTER_TRIMMED_TYPE) {
      const source = this.getStore().get("source");
      for (let index in trimmed) {
        if (trimmed[index] && isGrouping(source[index])) {
          trimmed[index] = false;
        }
      }
    }
  }
  isSortingRunning() {
    const sortingPlugin = this.providers.plugins.getByClass(SortingPlugin);
    return !!(sortingPlugin === null || sortingPlugin === void 0 ? void 0 : sortingPlugin.sortingPromise);
  }
  /**
   * Starts global source update with group clearing and applying new one
   * Initiated when need to reapply grouping
   */
  doSourceUpdate(options) {
    var _a;
    const store = this.getStore();
    const { source, prevExpanded, oldNewIndexes } = getSource(store.get("source"), store.get("proxyItems"), true);
    const expanded = Object.assign({ prevExpanded }, options);
    const { sourceWithGroups, depth, trimmed, oldNewIndexMap } = gatherGrouping(source, ((_a = this.options) === null || _a === void 0 ? void 0 : _a.props) || [], expanded);
    const customRenderer = options === null || options === void 0 ? void 0 : options.groupLabelTemplate;
    this.providers.data.setData(sourceWithGroups, GROUPING_ROW_TYPE, this.revogrid.disableVirtualY, { depth, customRenderer }, true);
    this.updateTrimmed(trimmed, oldNewIndexes !== null && oldNewIndexes !== void 0 ? oldNewIndexes : {}, oldNewIndexMap);
  }
  /**
   * Apply grouping on data set
   * Clear grouping from source
   * If source came from other plugin
   */
  onDataSet(data) {
    var _a, _b;
    let preservedExpanded = {};
    if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.preserveGroupingOnUpdate) !== false) {
      let { prevExpanded } = getSource(this.getStore().get("source"), this.getStore().get("proxyItems"), true);
      preservedExpanded = prevExpanded;
    }
    const source = data.source.filter((s) => !isGrouping(s));
    const options = Object.assign(Object.assign({}, this.revogrid.grouping || {}), { prevExpanded: preservedExpanded });
    const { sourceWithGroups, depth, trimmed, oldNewIndexMap } = gatherGrouping(source, ((_b = this.options) === null || _b === void 0 ? void 0 : _b.props) || [], options);
    data.source = sourceWithGroups;
    this.providers.data.setGrouping({ depth });
    this.updateTrimmed(trimmed, oldNewIndexMap);
  }
  /**
   * External call to apply grouping. Called by revogrid when prop changed.
   */
  setGrouping(options) {
    var _a, _b;
    this.clearSubscriptions();
    this.options = options;
    if (!((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.length)) {
      this.clearGrouping();
      return;
    }
    const store = this.getStore();
    const { source } = getSource(store.get("source"), store.get("proxyItems"));
    if (source.length) {
      this.doSourceUpdate(Object.assign({}, options));
    }
    for (let t of columnTypes) {
      if (this.setColumnGrouping(this.providers.column.getColumns(t))) {
        this.providers.column.refreshByType(t);
        break;
      }
    }
    this.addEventListener("beforesourceset", ({ detail }) => {
      var _a2, _b2, _c;
      if (!(((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.props) === null || _b2 === void 0 ? void 0 : _b2.length) && ((_c = detail === null || detail === void 0 ? void 0 : detail.source) === null || _c === void 0 ? void 0 : _c.length))) {
        return;
      }
      if (this.isSortingRunning()) {
        return;
      }
      this.onDataSet(detail);
    });
    this.addEventListener("beforecolumnsset", ({ detail }) => {
      this.setColumns(detail);
    });
    this.addEventListener("beforetrimmed", ({ detail: { trimmed, trimmedType } }) => this.beforeTrimmedApply(trimmed, trimmedType));
    this.addEventListener("aftersortingapply", () => {
      var _a2, _b2;
      if (!((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.props) === null || _b2 === void 0 ? void 0 : _b2.length)) {
        return;
      }
      this.doSourceUpdate(Object.assign({}, this.options));
    });
    this.addEventListener("beforecellfocus", (e) => this.onFocus(e));
    this.addEventListener("roworderchanged", (e) => this.onDrag(e));
    this.addEventListener(GROUP_EXPAND_EVENT, (e) => this.onExpand(e.detail));
  }
  // clear grouping
  clearGrouping() {
    columnTypes.forEach((t) => {
      const cols = this.providers.column.getColumns(t);
      let deleted = false;
      cols.forEach((c) => {
        if (isGroupingColumn(c)) {
          delete c[PSEUDO_GROUP_COLUMN];
          deleted = true;
        }
      });
      if (deleted) {
        this.providers.column.refreshByType(t);
      }
    });
    const { source, oldNewIndexes } = getSource(this.getStore().get("source"), this.getStore().get("proxyItems"), true);
    this.providers.data.setData(source, GROUPING_ROW_TYPE, this.revogrid.disableVirtualY, void 0, true);
    this.updateTrimmed(void 0, void 0, oldNewIndexes);
  }
  updateTrimmed(trimmedGroup = {}, firstLevelMap = {}, secondLevelMap) {
    const trimemedOptionsToUpgrade = processDoubleConversionTrimmed(this.getStore().get("trimmed"), firstLevelMap, secondLevelMap);
    for (let type in trimemedOptionsToUpgrade) {
      this.revogrid.addTrimmed(trimemedOptionsToUpgrade[type], type);
    }
    this.revogrid.addTrimmed(Object.assign({}, trimmedGroup), TRIMMED_GROUPING);
  }
};
var COLUMN_DRAG_CLASS = "column-drag-start";
var ColumnOrderHandler = class {
  constructor() {
    this.offset = 0;
  }
  renderAutoscroll(_, parent) {
    if (!parent) {
      return;
    }
    this.autoscrollEl = document.createElement("div");
    this.autoscrollEl.classList.add("drag-auto-scroll-y");
    parent.appendChild(this.autoscrollEl);
  }
  autoscroll(pos, dataContainerSize, direction = "translateX") {
    if (!this.autoscrollEl) {
      return;
    }
    const helperOffset = 10;
    const maxScroll = Math.min(pos + helperOffset, dataContainerSize - 3);
    this.autoscrollEl.style.transform = `${direction}(${maxScroll}px)`;
    this.autoscrollEl.scrollIntoView({
      block: "nearest",
      inline: "nearest"
    });
  }
  start(e, { dataEl, gridRect, scrollEl, gridEl }, dir = "left") {
    gridEl.classList.add(COLUMN_DRAG_CLASS);
    const scrollContainerRect = scrollEl.getBoundingClientRect();
    if (scrollContainerRect) {
      this.offset = scrollContainerRect[dir] - gridRect[dir];
    }
    this.renderAutoscroll(e, dataEl);
  }
  stop(gridEl) {
    var _a;
    gridEl.classList.remove(COLUMN_DRAG_CLASS);
    if (this.element) {
      this.element.hidden = true;
    }
    this.offset = 0;
    (_a = this.autoscrollEl) === null || _a === void 0 ? void 0 : _a.remove();
    this.autoscrollEl = void 0;
  }
  showHandler(pos, size2, direction = "translateX") {
    if (!this.element) {
      return;
    }
    if (this.offset) {
      pos = Math.max(pos, this.offset);
    }
    pos = Math.min(pos, size2);
    this.element.style.transform = `${direction}(${pos}px)`;
    this.element.hidden = false;
  }
  render() {
    const el = this.element = document.createElement("div");
    el.classList.add("drag-position-y");
    el.hidden = true;
    return el;
  }
};
var COLUMN_CLICK = ON_COLUMN_CLICK;
var MOVE = "columndragmousemove";
var DRAG_END = "columndragend";
var BEFORE_DRAG_END = "beforecolumndragend";
var DRAG_START = "columndragstart";
var ColumnMovePlugin = class extends BasePlugin {
  constructor(revogrid, providers) {
    super(revogrid, providers);
    this.moveFunc = debounce((e) => this.doMove(e), 5);
    this.staticDragData = null;
    this.dragData = null;
    this.localSubscriptions = {};
    this.orderUi = new ColumnOrderHandler();
    revogrid.appendChild(this.orderUi.render());
    revogrid.classList.add("column-draggable");
    this.localSubscriptions["mouseleave"] = {
      target: document,
      callback: (e) => this.onMouseOut(e)
    };
    this.localSubscriptions["mouseup"] = {
      target: document,
      callback: (e) => this.onMouseUp(e)
    };
    this.localSubscriptions["mousemove"] = {
      target: document,
      callback: (e) => this.move(e)
    };
    this.addEventListener(COLUMN_CLICK, ({ detail }) => this.dragStart(detail));
  }
  dragStart({ event, data }) {
    if (event.defaultPrevented) {
      return;
    }
    const { defaultPrevented } = dispatch(this.revogrid, DRAG_START, data);
    if (defaultPrevented) {
      return;
    }
    this.clearOrder();
    const { mouseleave, mouseup, mousemove } = this.localSubscriptions;
    mouseleave.target.addEventListener("mouseleave", mouseleave.callback);
    mouseup.target.addEventListener("mouseup", mouseup.callback);
    const dataEl = event.target.closest("revogr-header");
    const scrollEl = event.target.closest("revogr-viewport-scroll");
    if (!dataEl || !scrollEl) {
      return;
    }
    if (isColGrouping(data) || data.providers.type === "rowHeaders") {
      return;
    }
    const cols = this.getDimension(data.pin || "rgCol");
    const gridRect = this.revogrid.getBoundingClientRect();
    const elRect = dataEl.getBoundingClientRect();
    const startItem = getItemByPosition(cols, getLeftRelative(event.x, gridRect.left, elRect.left - gridRect.left));
    this.staticDragData = {
      startPos: event.x,
      startItem,
      pin: data.pin,
      dataEl,
      scrollEl,
      gridEl: this.revogrid,
      cols
    };
    this.dragData = this.getData(this.staticDragData);
    mousemove.target.addEventListener("mousemove", mousemove.callback);
    this.orderUi.start(event, Object.assign(Object.assign({}, this.dragData), this.staticDragData));
  }
  doMove(e) {
    if (!this.staticDragData) {
      return;
    }
    const dragData = this.dragData = this.getData(this.staticDragData);
    if (!dragData) {
      return;
    }
    const start = this.staticDragData.startPos;
    if (Math.abs(start - e.x) > 10) {
      const x = getLeftRelative(e.x, this.dragData.gridRect.left, this.dragData.scrollOffset);
      const rgCol = getItemByPosition(this.staticDragData.cols, x);
      this.orderUi.autoscroll(x, dragData.elRect.width);
      if (rgCol.itemIndex >= this.staticDragData.cols.count) {
        return;
      }
      this.orderUi.showHandler(rgCol.end + dragData.scrollOffset, dragData.gridRect.width);
    }
  }
  move(e) {
    dispatch(this.revogrid, MOVE, e);
    this.moveFunc(e);
  }
  onMouseOut(_) {
    this.clearOrder();
  }
  onMouseUp(e) {
    if (this.dragData && this.staticDragData) {
      let relativePos = getLeftRelative(e.x, this.dragData.gridRect.left, this.dragData.scrollOffset);
      if (relativePos < 0) {
        relativePos = 0;
      }
      const newPosition = getItemByPosition(this.staticDragData.cols, relativePos);
      const store = this.providers.column.stores[this.dragData.type].store;
      const newItems = [...store.get("items")];
      const { defaultPrevented: stopDrag } = dispatch(this.revogrid, BEFORE_DRAG_END, Object.assign(Object.assign({}, this.staticDragData), { startPosition: this.staticDragData.startItem, newPosition, newItem: store.get("source")[newItems[this.staticDragData.startItem.itemIndex]] }));
      if (!stopDrag) {
        const prevItems = [...newItems];
        const toMove = newItems.splice(this.staticDragData.startItem.itemIndex, 1);
        newItems.splice(newPosition.itemIndex, 0, ...toMove);
        store.set("items", newItems);
        this.providers.dimension.updateSizesPositionByNewDataIndexes(this.dragData.type, newItems, prevItems);
      }
      dispatch(this.revogrid, DRAG_END, this.dragData);
    }
    this.clearOrder();
  }
  clearLocalSubscriptions() {
    forEach(this.localSubscriptions, ({ target, callback }, key) => target.removeEventListener(key, callback));
  }
  clearOrder() {
    this.staticDragData = null;
    this.dragData = null;
    this.clearLocalSubscriptions();
    this.orderUi.stop(this.revogrid);
  }
  /**
   * Clearing subscription
   */
  clearSubscriptions() {
    super.clearSubscriptions();
    this.clearLocalSubscriptions();
  }
  getData({ gridEl, dataEl, pin }) {
    const gridRect = gridEl.getBoundingClientRect();
    const elRect = dataEl.getBoundingClientRect();
    const scrollOffset = elRect.left - gridRect.left;
    return {
      elRect,
      gridRect,
      type: pin || "rgCol",
      scrollOffset
    };
  }
  getDimension(type) {
    return this.providers.dimension.stores[type].getCurrentState();
  }
};
function getLeftRelative(absoluteX, gridPos, offset) {
  return absoluteX - gridPos - offset;
}

export {
  DimensionStore,
  SelectionStore,
  BasePlugin,
  AutoSizeColumnPlugin,
  StretchColumn,
  isStretchPlugin,
  ExportCsv,
  ExportFilePlugin,
  filterCoreFunctionsIndexedByType,
  filterTypes,
  filterNames,
  FILTER_TRIMMED_TYPE,
  FILTER_CONFIG_CHANGED_EVENT,
  FILTE_PANEL,
  FilterPlugin,
  sortIndexByItems,
  defaultCellCompare,
  descCellCompare,
  getNextOrder,
  getComparer,
  SortingPlugin,
  doCollapse,
  doExpand,
  GroupingRowPlugin,
  ColumnMovePlugin,
  getLeftRelative
};
/*! Bundled license information:

@revolist/revogrid/dist/esm/column.drag.plugin-CmcURdIJ.js:
  (*!
   * Built by Revolist OU 
   *)
*/
//# sourceMappingURL=chunk-G76XAFV2.js.map
