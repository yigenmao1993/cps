import {
  CELL_CLASS,
  DISABLED_CLASS,
  GRID_INTERNALS,
  baseIteratee,
  getSourceItem,
  getVisibleSourceItem,
  isArray,
  isArrayLike,
  isIterateeCall,
  keys,
  toFinite
} from "./chunk-52WLLNIP.js";

// node_modules/@revolist/revogrid/dist/esm/column.service-DT_CqxqZ.js
function toInteger(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index = -1, iterable = Object(collection);
    while (++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
  });
  return accumulator;
}
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
  return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach);
}
function getCellData(val) {
  if (typeof val === "undefined" || val === null) {
    return "";
  }
  return val;
}
function getCellRaw(model = {}, column) {
  if (!column) {
    return;
  }
  if (column.cellParser) {
    return column.cellParser(model, column);
  }
  return model[column.prop];
}
function getCellDataParsed(model, column) {
  return getCellData(getCellRaw(model, column));
}
function getColumnType(rgCol) {
  if (rgCol.pin) {
    return rgCol.pin;
  }
  return "rgCol";
}
function getColumnSizes(cols) {
  const res = {};
  for (const [i, c] of cols.entries()) {
    if (c.size) {
      res[i] = c.size;
    }
  }
  return res;
}
function isColGrouping(colData) {
  return !!colData.children;
}
function getColumns(columns, level = 0, types, resFromRoot) {
  const collection = {
    // columns as they are in stores per type
    columns: {
      rgCol: [],
      colPinStart: [],
      colPinEnd: []
    },
    // columns indexed by prop for quick access
    columnByProp: {},
    // column grouping
    columnGrouping: {
      rgCol: [],
      colPinStart: [],
      colPinEnd: []
    },
    // sorting
    sort: {},
    // max depth level for column grouping
    maxLevel: level
  };
  return reduce(columns, (res, colData) => {
    var _a;
    if (isColGrouping(colData)) {
      res = gatherGroup(res, colData, getColumns(colData.children, level + 1, types, res), resFromRoot === null || resFromRoot === void 0 ? void 0 : resFromRoot.columns, level);
      return res;
    }
    const columnDefinitionFromType = colData.columnType && (types === null || types === void 0 ? void 0 : types[colData.columnType]);
    const regularColumn = Object.assign(Object.assign({}, columnDefinitionFromType), colData);
    if (!regularColumn.pin) {
      res.columns.rgCol.push(regularColumn);
    } else {
      res.columns[regularColumn.pin].push(regularColumn);
    }
    if (regularColumn.order) {
      res.sort[regularColumn.prop] = regularColumn;
    }
    if (!res.columnByProp[regularColumn.prop]) {
      res.columnByProp[regularColumn.prop] = [];
    }
    res.columnByProp[regularColumn.prop].push(regularColumn);
    (_a = regularColumn.beforeSetup) === null || _a === void 0 ? void 0 : _a.call(regularColumn, regularColumn);
    return res;
  }, collection);
}
function gatherGroup(res, colData, collection, existingColumnsByType, level = 0) {
  const group = Object.assign(Object.assign({}, colData), { level, indexes: [] });
  columnTypes.forEach((type) => {
    const resultItem = res.columns[type];
    const collectionItem = collection.columns[type];
    if (isArray(resultItem) && isArray(collectionItem)) {
      const itemLength = collectionItem.length;
      if (itemLength) {
        const columnLength = [...(existingColumnsByType === null || existingColumnsByType === void 0 ? void 0 : existingColumnsByType[type]) || [], ...resultItem].length;
        resultItem.push(...collectionItem);
        res.columnGrouping[type].push(Object.assign(Object.assign({}, group), { indexes: Array(itemLength).fill(columnLength).map((v, i) => v + i) }));
      }
    }
  });
  for (let k in collection.columnGrouping) {
    const key = k;
    const collectionItem = collection.columnGrouping[key];
    res.columnGrouping[key].push(...collectionItem);
  }
  res.maxLevel = Math.max(res.maxLevel, collection.maxLevel);
  res.sort = Object.assign(Object.assign({}, res.sort), collection.sort);
  res.columnByProp = Object.assign(Object.assign({}, res.columnByProp), collection.columnByProp);
  return res;
}
function findColumn(columns, prop) {
  for (const c of columns) {
    if (isColGrouping(c)) {
      const found = findColumn(c.children, prop);
      if (found) {
        return found;
      }
    } else if (c.prop === prop) {
      return c;
    }
  }
  return void 0;
}
function getColumnByProp(columns, prop) {
  return findColumn(columns, prop);
}
function nextCell(cell, lastCell) {
  const nextItem = {};
  let types = ["x", "y"];
  for (let t of types) {
    if (cell[t] < 0) {
      nextItem[t] = cell[t];
      return nextItem;
    }
  }
  for (let t of types) {
    if (cell[t] >= lastCell[t]) {
      nextItem[t] = cell[t] - lastCell[t];
      return nextItem;
    }
  }
  return null;
}
function cropCellToMax(cell, lastCell) {
  const croppedCell = Object.assign({}, cell);
  const cellCoordinates = ["x", "y"];
  for (const coordinate of cellCoordinates) {
    if (cell[coordinate] < 0) {
      croppedCell[coordinate] = 0;
    } else if (cell[coordinate] >= lastCell[coordinate]) {
      croppedCell[coordinate] = lastCell[coordinate] - 1;
    }
  }
  return croppedCell;
}
function getRange(start, end) {
  return start && end ? {
    x: Math.min(start.x, end.x),
    y: Math.min(start.y, end.y),
    x1: Math.max(start.x, end.x),
    y1: Math.max(start.y, end.y)
  } : null;
}
function isRangeSingleCell(a) {
  return a.x === a.x1 && a.y === a.y1;
}
var rowTypes = ["rowPinStart", "rgRow", "rowPinEnd"];
var columnTypes = [
  "colPinStart",
  "rgCol",
  "colPinEnd"
];
function isRowType(type) {
  return rowTypes.indexOf(type) > -1;
}
var GROUP_DEPTH = `${GRID_INTERNALS}-depth`;
var PSEUDO_GROUP_ITEM = `${GRID_INTERNALS}-name`;
var PSEUDO_GROUP_ITEM_ID = `${GRID_INTERNALS}-id`;
var PSEUDO_GROUP_ITEM_VALUE = `${GRID_INTERNALS}-value`;
var PSEUDO_GROUP_COLUMN = `${GRID_INTERNALS}-column`;
var GROUP_EXPANDED = `${GRID_INTERNALS}-expanded`;
var GROUP_COLUMN_PROP = `${GRID_INTERNALS}-prop`;
var GROUP_ORIGINAL_INDEX = `${GRID_INTERNALS}-original-index`;
var GROUP_EXPAND_BTN = `group-expand`;
var GROUP_EXPAND_EVENT = `groupexpandclick`;
var GROUPING_ROW_TYPE = "rgRow";
function getGroupValueDefault(item, prop) {
  return item[prop] || null;
}
function getSource(source, items, withoutGrouping = false) {
  let index = 0;
  const result = {
    source: [],
    prevExpanded: {},
    oldNewIndexes: {}
  };
  items.forEach((i) => {
    const model = source[i];
    if (!withoutGrouping) {
      result.source.push(model);
      return;
    }
    if (isGrouping(model)) {
      if (getExpanded(model)) {
        result.prevExpanded[model[PSEUDO_GROUP_ITEM_VALUE]] = true;
      }
    } else {
      result.source.push(model);
      result.oldNewIndexes[i] = index;
      index++;
    }
  });
  return result;
}
function getExpanded(model = {}) {
  return model[GROUP_EXPANDED];
}
function flattenGroupMaps({ groupedValues, parentIds, isExpanded, itemIndex, expandedAll, prevExpanded, columnProps }) {
  const depth = parentIds.length;
  const sourceWithGroups = [];
  let trimmed = {};
  let oldNewIndexMap = {};
  groupedValues.forEach((innerGroupedValues, groupId) => {
    const levelIds = [...parentIds, groupId];
    const mergedIds = levelIds.join(",");
    const isGroupExpanded = isExpanded && (!!expandedAll || !!prevExpanded[mergedIds]);
    sourceWithGroups.push({
      [PSEUDO_GROUP_ITEM]: groupId,
      [GROUP_DEPTH]: depth,
      [PSEUDO_GROUP_ITEM_ID]: JSON.stringify(levelIds),
      [PSEUDO_GROUP_ITEM_VALUE]: mergedIds,
      [GROUP_EXPANDED]: isGroupExpanded,
      [GROUP_COLUMN_PROP]: columnProps[depth],
      [columnProps[depth]]: groupId
    });
    itemIndex += 1;
    if (!isExpanded && depth) {
      trimmed[itemIndex] = true;
    }
    if (Array.isArray(innerGroupedValues)) {
      innerGroupedValues.forEach((value) => {
        itemIndex += 1;
        if (!isGroupExpanded) {
          trimmed[itemIndex] = true;
        }
        oldNewIndexMap[value[GROUP_ORIGINAL_INDEX]] = itemIndex;
      });
      sourceWithGroups.push(...innerGroupedValues);
    } else {
      const children = flattenGroupMaps({
        groupedValues: innerGroupedValues,
        parentIds: levelIds,
        isExpanded: isGroupExpanded,
        itemIndex,
        expandedAll,
        prevExpanded,
        columnProps
      });
      sourceWithGroups.push(...children.source);
      trimmed = Object.assign(Object.assign({}, children.trimmed), trimmed);
      oldNewIndexMap = Object.assign(Object.assign({}, children.oldNewIndexMap), oldNewIndexMap);
      itemIndex = children.itemIndex;
    }
  });
  return {
    source: sourceWithGroups,
    oldNewIndexMap,
    trimmed,
    itemIndex
  };
}
function gatherGrouping(array, columnProps, { prevExpanded = {}, expandedAll = false, getGroupValue = getGroupValueDefault }) {
  const groupedItems = /* @__PURE__ */ new Map();
  array.forEach((item, originalIndex) => {
    const groupLevelValues = columnProps.map((groupId) => getGroupValue(item, groupId));
    const lastLevelValue = groupLevelValues.pop();
    let currentGroupLevel = groupedItems;
    groupLevelValues.forEach((value) => {
      if (!currentGroupLevel.has(value)) {
        currentGroupLevel.set(value, /* @__PURE__ */ new Map());
      }
      currentGroupLevel = currentGroupLevel.get(value);
    });
    if (!currentGroupLevel.has(lastLevelValue)) {
      const groupItems = [];
      currentGroupLevel.set(lastLevelValue, groupItems);
    }
    const lastLevelItems = currentGroupLevel.get(lastLevelValue);
    lastLevelItems.push(Object.assign(Object.assign({}, item), { [GROUP_ORIGINAL_INDEX]: originalIndex }));
  });
  const groupingDepth = columnProps.length;
  const { source: sourceWithGroups, trimmed, oldNewIndexMap } = flattenGroupMaps({
    groupedValues: groupedItems,
    parentIds: [],
    isExpanded: true,
    itemIndex: -1,
    expandedAll,
    prevExpanded,
    columnProps
  });
  return {
    sourceWithGroups,
    // updates source mirror
    depth: groupingDepth,
    // largest depth for grouping
    trimmed,
    // used for expand/collapse grouping values
    oldNewIndexMap
    // used for mapping old values to new
  };
}
function getGroupingName(rgRow) {
  return rgRow === null || rgRow === void 0 ? void 0 : rgRow[PSEUDO_GROUP_ITEM];
}
function isGrouping(rgRow) {
  return typeof (rgRow === null || rgRow === void 0 ? void 0 : rgRow[PSEUDO_GROUP_ITEM]) !== "undefined";
}
function isGroupingColumn(column) {
  return typeof (column === null || column === void 0 ? void 0 : column[PSEUDO_GROUP_COLUMN]) !== "undefined";
}
function measureEqualDepth(groupA, groupB) {
  const ln = groupA.length;
  let i = 0;
  for (; i < ln; i++) {
    if (groupA[i] !== groupB[i]) {
      return i;
    }
  }
  return i;
}
function getParsedGroup(id) {
  const parseGroup = JSON.parse(id);
  if (!Array.isArray(parseGroup)) {
    return null;
  }
  return parseGroup;
}
function isSameGroup(currentGroup, currentModel, nextModel) {
  const nextGroup = getParsedGroup(nextModel[PSEUDO_GROUP_ITEM_ID]);
  if (!nextGroup) {
    return false;
  }
  const depth = measureEqualDepth(currentGroup, nextGroup);
  return currentModel[GROUP_DEPTH] < depth;
}
function baseSlice(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
function slice(array, start, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
    start = 0;
    end = length;
  } else {
    start = start == null ? 0 : toInteger(start);
    end = end === void 0 ? length : toInteger(end);
  }
  return baseSlice(array, start, end);
}
function getCellEditor(column, editors = {}) {
  const editor = column === null || column === void 0 ? void 0 : column.editor;
  if (!editor) {
    return void 0;
  }
  if (typeof editor === "string") {
    return editors[editor];
  }
  return editor;
}
var ColumnService = class {
  get columns() {
    return getVisibleSourceItem(this.source);
  }
  constructor(dataStore, source) {
    this.dataStore = dataStore;
    this.source = source;
    this.unsubscribe = [];
    this.hasGrouping = false;
    this.unsubscribe.push(source.onChange("source", (s) => this.checkGrouping(s)));
    this.checkGrouping(source.get("source"));
    this.type = source.get("type");
  }
  checkGrouping(cols) {
    for (let rgCol of cols) {
      if (isGroupingColumn(rgCol)) {
        this.hasGrouping = true;
        return;
      }
      this.hasGrouping = false;
    }
  }
  isReadOnly(r, c) {
    var _a;
    const readOnly = (_a = this.columns[c]) === null || _a === void 0 ? void 0 : _a.readonly;
    if (typeof readOnly === "function") {
      const data = this.rowDataModel(r, c);
      return readOnly(data);
    }
    return !!readOnly;
  }
  mergeProperties(r, c, defaultProps, schemaModel) {
    var _a, _b;
    const props = Object.assign({}, defaultProps);
    props.class = Object.assign(Object.assign({}, typeof props.class === "string" ? { [props.class]: true } : props.class), { [CELL_CLASS]: true, [DISABLED_CLASS]: this.isReadOnly(r, c) });
    const extra = (_b = (_a = schemaModel.column) === null || _a === void 0 ? void 0 : _a.cellProperties) === null || _b === void 0 ? void 0 : _b.call(_a, schemaModel);
    if (!extra) {
      return props;
    }
    return doPropMerge(props, extra);
  }
  getRowClass(r, prop) {
    const model = getSourceItem(this.dataStore, r) || {};
    return model[prop] || "";
  }
  getSaveData(rowIndex, colIndex, val) {
    const data = this.rowDataModel(rowIndex, colIndex);
    if (typeof val === "undefined") {
      val = getCellData(data.value);
    }
    return Object.assign(Object.assign({}, data), { val });
  }
  /**
   * Get cell data model for given rowIndex and colIndex
   * Used to pass data to editor/renderer
   */
  rowDataModel(rowIndex, colIndex) {
    const column = this.columns[colIndex];
    const prop = column === null || column === void 0 ? void 0 : column.prop;
    const model = getSourceItem(this.dataStore, rowIndex) || {};
    const type = this.dataStore.get("type");
    return {
      prop,
      model,
      data: this.dataStore.get("source"),
      column,
      rowIndex,
      colIndex,
      colType: this.type,
      type,
      value: getCellRaw(model, column)
    };
  }
  getRangeData(d, columns) {
    var _a;
    const changed = {};
    const copyColLength = d.oldRange.x1 - d.oldRange.x + 1;
    const copyRowLength = d.oldRange.y1 - d.oldRange.y + 1;
    const mapping = {};
    for (let rowIndex = d.newRange.y, i = 0; rowIndex < d.newRange.y1 + 1; rowIndex++, i++) {
      const oldRowIndex = d.oldRange.y + i % copyRowLength;
      const copyRow = getSourceItem(this.dataStore, oldRowIndex) || {};
      for (let colIndex = d.newRange.x, j = 0; colIndex < d.newRange.x1 + 1; colIndex++, j++) {
        if (rowIndex >= d.oldRange.y && rowIndex <= d.oldRange.y1 && colIndex >= d.oldRange.x && colIndex <= d.oldRange.x1) {
          continue;
        }
        if (!this.columns[colIndex]) {
          continue;
        }
        const prop = (_a = this.columns[colIndex]) === null || _a === void 0 ? void 0 : _a.prop;
        const copyColIndex = d.oldRange.x + j % copyColLength;
        const copyColumnProp = columns[copyColIndex].prop;
        if (!this.isReadOnly(rowIndex, colIndex)) {
          if (!changed[rowIndex]) {
            changed[rowIndex] = {};
          }
          changed[rowIndex][prop] = copyRow[copyColumnProp];
          if (!mapping[rowIndex]) {
            mapping[rowIndex] = {};
          }
          mapping[rowIndex][prop] = {
            colIndex: copyColIndex,
            colProp: copyColumnProp,
            rowIndex: oldRowIndex
          };
        }
      }
    }
    return {
      changed,
      mapping
    };
  }
  getTransformedDataToApply(start, data) {
    const changed = {};
    const copyRowLength = data.length;
    const colLength = this.columns.length;
    const rowLength = this.dataStore.get("items").length;
    let rowIndex = start.y;
    let maxCol = 0;
    for (let i = 0; rowIndex < rowLength && i < copyRowLength; rowIndex++, i++) {
      const copyRow = data[i % copyRowLength];
      const copyColLength = (copyRow === null || copyRow === void 0 ? void 0 : copyRow.length) || 0;
      let colIndex = start.x;
      for (let j = 0; colIndex < colLength && j < copyColLength; colIndex++, j++) {
        const p = this.columns[colIndex].prop;
        const currentCol = j % colLength;
        if (!this.isReadOnly(rowIndex, colIndex)) {
          if (!changed[rowIndex]) {
            changed[rowIndex] = {};
          }
          changed[rowIndex][p] = copyRow[currentCol];
        }
      }
      maxCol = Math.max(maxCol, colIndex - 1);
    }
    const range = getRange(start, {
      y: rowIndex - 1,
      x: maxCol
    });
    return {
      changed,
      range
    };
  }
  getRangeStaticData(d, value) {
    const changed = {};
    for (let rowIndex = d.y, i = 0; rowIndex < d.y1 + 1; rowIndex++, i++) {
      for (let colIndex = d.x, j = 0; colIndex < d.x1 + 1; colIndex++, j++) {
        if (!this.columns[colIndex]) {
          continue;
        }
        const p = this.columns[colIndex].prop;
        if (!this.isReadOnly(rowIndex, colIndex)) {
          if (!changed[rowIndex]) {
            changed[rowIndex] = {};
          }
          changed[rowIndex][p] = value;
        }
      }
    }
    return changed;
  }
  getRangeTransformedToProps(d, store) {
    var _a;
    const area = [];
    const type = this.dataStore.get("type");
    for (let rowIndex = d.y, i = 0; rowIndex < d.y1 + 1; rowIndex++, i++) {
      for (let colIndex = d.x, j = 0; colIndex < d.x1 + 1; colIndex++, j++) {
        const prop = (_a = this.columns[colIndex]) === null || _a === void 0 ? void 0 : _a.prop;
        area.push({
          prop,
          rowIndex,
          colIndex,
          model: getSourceItem(store, rowIndex),
          type,
          colType: this.type
        });
      }
    }
    return area;
  }
  copyRangeArray(range, store) {
    const cols = [...this.columns];
    const props = slice(cols, range.x, range.x1 + 1).map((v) => v.prop);
    const toCopy = [];
    const mapping = {};
    for (let i = range.y; i <= range.y1; i++) {
      const rgRow = [];
      mapping[i] = {};
      for (let prop of props) {
        const item = getSourceItem(store, i);
        if (!item) {
          continue;
        }
        const val = item[prop];
        rgRow.push(val);
        mapping[i][prop] = val;
      }
      toCopy.push(rgRow);
    }
    return {
      data: toCopy,
      mapping
    };
  }
  destroy() {
    this.unsubscribe.forEach((f) => f());
  }
};
function isRowDragService(rowDrag, model) {
  if (typeof rowDrag === "function") {
    return rowDrag(model);
  }
  return !!rowDrag;
}
function mergeClasses(class1 = {}, class2 = {}) {
  if (typeof class1 === "string") {
    class1 = { [class1]: true };
  }
  if (typeof class2 === "string") {
    class2 = { [class2]: true };
  }
  return Object.assign(Object.assign({}, class1), class2);
}
function doPropMerge(existing, extra) {
  if (extra.className) {
    extra.class = mergeClasses(extra.class, extra.className);
    delete extra.className;
  }
  let props = Object.assign(Object.assign({}, extra), existing);
  if (extra.class) {
    props.class = mergeClasses(props.class, extra.class);
  }
  if (extra.style) {
    props.style = Object.assign(Object.assign({}, extra.style), props.style);
  }
  return props;
}

export {
  toInteger,
  baseEach,
  reduce,
  getCellData,
  getCellRaw,
  getCellDataParsed,
  getColumnType,
  getColumnSizes,
  isColGrouping,
  getColumns,
  gatherGroup,
  getColumnByProp,
  nextCell,
  cropCellToMax,
  getRange,
  isRangeSingleCell,
  rowTypes,
  columnTypes,
  isRowType,
  GROUP_DEPTH,
  PSEUDO_GROUP_ITEM,
  PSEUDO_GROUP_ITEM_ID,
  PSEUDO_GROUP_ITEM_VALUE,
  PSEUDO_GROUP_COLUMN,
  GROUP_EXPANDED,
  GROUP_COLUMN_PROP,
  GROUP_ORIGINAL_INDEX,
  GROUP_EXPAND_BTN,
  GROUP_EXPAND_EVENT,
  GROUPING_ROW_TYPE,
  getSource,
  getExpanded,
  gatherGrouping,
  getGroupingName,
  isGrouping,
  isGroupingColumn,
  measureEqualDepth,
  getParsedGroup,
  isSameGroup,
  getCellEditor,
  ColumnService,
  isRowDragService,
  doPropMerge
};
/*! Bundled license information:

@revolist/revogrid/dist/esm/column.service-DT_CqxqZ.js:
  (*!
   * Built by Revolist OU ❤️
   *)
*/
//# sourceMappingURL=chunk-QZAIXLNJ.js.map
