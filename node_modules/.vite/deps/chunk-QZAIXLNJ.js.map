{
  "version": 3,
  "sources": ["../../@revolist/revogrid/dist/esm/node_modules/lodash/toInteger.js", "../../@revolist/revogrid/dist/esm/node_modules/lodash/_arrayReduce.js", "../../@revolist/revogrid/dist/esm/node_modules/lodash/_createBaseFor.js", "../../@revolist/revogrid/dist/esm/node_modules/lodash/_baseFor.js", "../../@revolist/revogrid/dist/esm/node_modules/lodash/_baseForOwn.js", "../../@revolist/revogrid/dist/esm/node_modules/lodash/_createBaseEach.js", "../../@revolist/revogrid/dist/esm/node_modules/lodash/_baseEach.js", "../../@revolist/revogrid/dist/esm/node_modules/lodash/_baseReduce.js", "../../@revolist/revogrid/dist/esm/node_modules/lodash/reduce.js", "../../@revolist/revogrid/dist/esm/src/utils/column.utils.ts", "../../@revolist/revogrid/dist/esm/src/store/selection/selection.helpers.ts", "../../@revolist/revogrid/dist/esm/src/store/index.ts", "../../@revolist/revogrid/dist/esm/src/plugins/groupingRow/grouping.const.ts", "../../@revolist/revogrid/dist/esm/src/plugins/groupingRow/grouping.service.ts", "../../@revolist/revogrid/dist/esm/node_modules/lodash/_baseSlice.js", "../../@revolist/revogrid/dist/esm/node_modules/lodash/slice.js", "../../@revolist/revogrid/dist/esm/src/components/data/column.service.ts"],
  "sourcesContent": ["import toFinite from './toFinite.js';\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nexport default toInteger;\n", "/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nexport default arrayReduce;\n", "/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nexport default createBaseFor;\n", "import createBaseFor from './_createBaseFor.js';\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nexport default baseFor;\n", "import baseFor from './_baseFor.js';\nimport keys from './keys.js';\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nexport default baseForOwn;\n", "import isArrayLike from './isArrayLike.js';\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nexport default createBaseEach;\n", "import baseForOwn from './_baseForOwn.js';\nimport createBaseEach from './_createBaseEach.js';\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nexport default baseEach;\n", "/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nexport default baseReduce;\n", "import arrayReduce from './_arrayReduce.js';\nimport baseEach from './_baseEach.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseReduce from './_baseReduce.js';\nimport isArray from './isArray.js';\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nexport default reduce;\n", "import isArray from 'lodash/isArray';\nimport reduce from 'lodash/reduce';\n\nimport type {\n  ColumnData,\n  ColumnGrouping,\n  ColumnProp,\n  ColumnRegular,\n  ColumnTypes,\n  DataType,\n  DimensionCols,\n  ViewSettingSizeProp,\n} from '@type';\nimport { columnTypes, type Group as StoreGroup } from '@store';\n\nexport type ColumnItems = Record<DimensionCols, ColumnRegular[]>;\nexport interface ColumnGroup extends StoreGroup {\n  level: number;\n}\nexport type ColumnGroupingCollection = Record<DimensionCols, ColumnGroup[]>;\n\nexport function getCellData(val?: any) {\n  if (typeof val === 'undefined' || val === null) {\n    return '';\n  }\n  return val;\n}\n\nexport function getCellRaw(model: DataType = {}, column?: ColumnRegular) {\n  if (!column) {\n    return;\n  }\n  if (column.cellParser) {\n    return column.cellParser(model, column);\n  }\n  return model[column.prop];\n}\n\nexport function getCellDataParsed(model: DataType, column: ColumnRegular) {\n  return getCellData(getCellRaw(model, column));\n}\n\n/**\n * Column collection definition.\n * Used to access indexed data for columns.\n * Can be accessed via different events.\n */\nexport type ColumnCollection = {\n  /**\n   * Columns as they are in stores\n   */\n  columns: Record<DimensionCols, ColumnRegular[]>;\n  /**\n   * Columns indexed by prop for quick access, it's possible to have multiple columns with same prop but not recommended\n   */\n  columnByProp: Record<ColumnProp, ColumnRegular[]>;\n  /**\n   * Grouped columns\n   */\n  columnGrouping: ColumnGroupingCollection;\n  /**\n   * Max level of grouping\n   */\n  maxLevel: number;\n  /**\n   * Sorting\n   */\n  sort: Record<ColumnProp, ColumnRegular>;\n};\n\n/**\n * Get column type from column data\n */\nexport function getColumnType(rgCol: ColumnRegular): DimensionCols {\n  if (rgCol.pin) {\n    return rgCol.pin;\n  }\n  return 'rgCol';\n}\n\nexport function getColumnSizes(cols: ColumnRegular[]): ViewSettingSizeProp {\n  const res: ViewSettingSizeProp = {};\n  for (const [i, c] of cols.entries()) {\n    if (c.size) {\n      res[i] = c.size;\n    }\n  }\n  return res;\n}\n\n\n/**\n * Check if column is grouping column\n */\nexport function isColGrouping(\n  colData: ColumnGrouping | ColumnRegular,\n): colData is ColumnGrouping {\n  return !!(colData as ColumnGrouping).children;\n}\n\n/**\n * This function is used to create a collection of columns.\n */\nexport function getColumns(\n  columns: ColumnData,\n  level = 0,\n  types?: ColumnTypes,\n  resFromRoot?: Partial<ColumnCollection>\n): ColumnCollection {\n  const collection: ColumnCollection = {\n    // columns as they are in stores per type\n    columns: {\n      rgCol: [],\n      colPinStart: [],\n      colPinEnd: [],\n    },\n    // columns indexed by prop for quick access\n    columnByProp: {},\n    // column grouping\n    columnGrouping: {\n      rgCol: [],\n      colPinStart: [],\n      colPinEnd: [],\n    },\n    // sorting\n    sort: {},\n    // max depth level for column grouping\n    maxLevel: level,\n  };\n\n  return reduce(\n    columns,\n    (res: ColumnCollection, colData: ColumnGrouping | ColumnRegular) => {\n      // Grouped column\n      if (isColGrouping(colData)) {\n        res = gatherGroup(\n          res,\n          colData,\n          getColumns(colData.children, level + 1, types, res),\n          resFromRoot?.columns,\n          level,\n        );\n        return res;\n      }\n      // Column type\n      const columnDefinitionFromType = colData.columnType && types?.[colData.columnType];\n      // Regular column\n      const regularColumn = {\n        ...columnDefinitionFromType,\n        ...colData,\n      };\n      // Regular column, no Pin\n      if (!regularColumn.pin) {\n        res.columns.rgCol.push(regularColumn);\n        // Pin\n      } else {\n        res.columns[regularColumn.pin].push(regularColumn);\n      }\n      if (regularColumn.order) {\n        res.sort[regularColumn.prop] = regularColumn;\n      }\n      // it's possible that some columns have same prop, but better to avoid it\n      if (!res.columnByProp[regularColumn.prop]) {\n        res.columnByProp[regularColumn.prop] = [];\n      }\n      res.columnByProp[regularColumn.prop].push(regularColumn);\n\n      // trigger setup hook if present\n      regularColumn.beforeSetup?.(regularColumn);\n      return res;\n    },\n    collection,\n  );\n}\n\nexport function gatherGroup<T extends ColumnCollection>(\n  res: T,\n  colData: ColumnGrouping,\n  collection: T,\n  existingColumnsByType?: ColumnCollection['columns'],\n  level = 0,\n): T {\n  // group template\n  const group: ColumnGroup = {\n    ...colData,\n    level,\n    indexes: [],\n  };\n\n  // check columns for update\n  columnTypes.forEach(type => {\n    const resultItem = res.columns[type];\n    const collectionItem = collection.columns[type];\n\n    // if column data\n    if (isArray(resultItem) && isArray(collectionItem)) {\n\n      // fill grouping\n      const itemLength = collectionItem.length;\n      if (itemLength) {\n        const columnLength = [...(existingColumnsByType?.[type] || []), ...resultItem].length;\n        // fill columns\n        resultItem.push(...collectionItem);\n\n        // fill indexes per each viewport\n        res.columnGrouping[type].push({\n          ...group,\n          indexes: Array(itemLength).fill(columnLength).map((v, i) => v + i),\n        });\n      }\n    }\n  });\n  // merge column groupings\n  for (let k in collection.columnGrouping) {\n    const key = k as DimensionCols;\n    const collectionItem = collection.columnGrouping[key];\n    res.columnGrouping[key].push(...collectionItem);\n  }\n  res.maxLevel = Math.max(res.maxLevel, collection.maxLevel);\n  res.sort = { ...res.sort, ...collection.sort };\n  res.columnByProp = {\n    ...res.columnByProp,\n    ...collection.columnByProp,\n  };\n  return res;\n}\n\nfunction findColumn(\n  columns: ColumnData,\n  prop: ColumnProp,\n): ColumnRegular | undefined {\n  for (const c of columns) {\n    if (isColGrouping(c)) {\n      const found = findColumn(c.children, prop);\n      if (found) {\n        return found;\n      }\n    } else if (c.prop === prop) {\n      return c;\n    }\n  }\n  return undefined;\n}\n\nexport function getColumnByProp(\n  columns: ColumnData,\n  prop: ColumnProp,\n): ColumnRegular | undefined {\n  return findColumn(columns, prop);\n}\n", "import { Cell, RangeArea } from '@type';\n\nexport function nextCell(cell: Cell, lastCell: Cell): Partial<Cell> | null {\n  const nextItem: Partial<Cell> = {};\n  let types: (keyof Cell)[] = ['x', 'y'];\n\n  // previous item check\n  for (let t of types) {\n    if (cell[t] < 0) {\n      nextItem[t] = cell[t];\n      return nextItem;\n    }\n  }\n  // next item check\n  for (let t of types) {\n    if (cell[t] >= lastCell[t]) {\n      nextItem[t] = cell[t] - lastCell[t];\n      return nextItem;\n    }\n  }\n  return null;\n}\n\nexport function cropCellToMax(cell: Cell, lastCell: Cell): Cell {\n  const croppedCell: Cell = { ...cell };\n  const cellCoordinates: (keyof Cell)[] = ['x', 'y'];\n\n  for (const coordinate of cellCoordinates) {\n    if (cell[coordinate] < 0) {\n      croppedCell[coordinate] = 0;\n    } else if (cell[coordinate] >= lastCell[coordinate]) {\n      croppedCell[coordinate] = lastCell[coordinate] - 1;\n    }\n  }\n\n  return croppedCell;\n}\n\nexport function getRange(start?: Cell | null, end?: Cell | null): RangeArea | null {\n  return start && end\n    ? {\n        x: Math.min(start.x, end.x),\n        y: Math.min(start.y, end.y),\n        x1: Math.max(start.x, end.x),\n        y1: Math.max(start.y, end.y),\n      }\n    : null;\n}\n\nexport function isRangeSingleCell(a: RangeArea): boolean {\n  return a.x === a.x1 && a.y === a.y1;\n}\n", "import type { DimensionCols, DimensionRows } from '@type';\n\nexport * from './dataSource';\nexport * from './dimension';\nexport * from './selection';\nexport * from './vp';\n\nexport const rowTypes: DimensionRows[] = ['rowPinStart', 'rgRow', 'rowPinEnd'];\nexport const columnTypes: DimensionCols[] = [\n  'colPinStart',\n  'rgCol',\n  'colPinEnd',\n];\n\nexport function isRowType(type: DimensionRows | any): type is DimensionRows {\n  return rowTypes.indexOf(type) > -1;\n}\n", "import { DimensionRows } from '@type';\nimport { GRID_INTERNALS } from '../../utils/consts';\n\nexport const GROUP_DEPTH = `${GRID_INTERNALS}-depth`;\nexport const PSEUDO_GROUP_ITEM = `${GRID_INTERNALS}-name`;\nexport const PSEUDO_GROUP_ITEM_ID = `${GRID_INTERNALS}-id`;\nexport const PSEUDO_GROUP_ITEM_VALUE = `${GRID_INTERNALS}-value`;\nexport const PSEUDO_GROUP_COLUMN = `${GRID_INTERNALS}-column`;\nexport const GROUP_EXPANDED = `${GRID_INTERNALS}-expanded`;\nexport const GROUP_COLUMN_PROP = `${GRID_INTERNALS}-prop`;\nexport const GROUP_ORIGINAL_INDEX = `${GRID_INTERNALS}-original-index`;\nexport const GROUP_EXPAND_BTN = `group-expand`;\nexport const GROUP_EXPAND_EVENT = `groupexpandclick`;\nexport const GROUPING_ROW_TYPE: DimensionRows = 'rgRow';\n", "import type { DataType, ColumnProp, ColumnRegular } from '@type';\nimport {\n  GROUP_DEPTH,\n  GROUP_EXPANDED,\n  PSEUDO_GROUP_COLUMN,\n  PSEUDO_GROUP_ITEM,\n  PSEUDO_GROUP_ITEM_ID,\n  PSEUDO_GROUP_ITEM_VALUE,\n  GROUP_ORIGINAL_INDEX,\n  GROUP_COLUMN_PROP,\n} from './grouping.const';\nimport type { ExpandedOptions } from './grouping.row.types';\n\ntype GroupedData = Map<string, GroupedData | DataType[]>;\ntype SourceGather = {\n  source: DataType[];\n  prevExpanded: Record<string, boolean>;\n  oldNewIndexes?: Record<number, number>;\n};\n\nfunction getGroupValueDefault(item: DataType, prop: string | number) {\n  return item[prop] || null;\n}\n\n// get source based on proxy item collection to preserve rgRow order\nexport function getSource(\n  source: DataType[],\n  items: number[],\n  withoutGrouping = false,\n) {\n  let index = 0;\n  const result: Required<SourceGather> = {\n    source: [],\n    prevExpanded: {},\n    oldNewIndexes: {},\n  };\n  // order important here, expected parent is first, then others\n  items.forEach(i => {\n    const model = source[i];\n    if (!withoutGrouping) {\n      result.source.push(model);\n      return;\n    }\n\n    // grouping filter\n    if (isGrouping(model)) {\n      if (getExpanded(model)) {\n        result.prevExpanded[model[PSEUDO_GROUP_ITEM_VALUE]] = true;\n      }\n    } else {\n      result.source.push(model);\n      result.oldNewIndexes[i] = index;\n      index++;\n    }\n  });\n  return result;\n}\n\nexport function getExpanded(model: DataType = {}) {\n  return model[GROUP_EXPANDED];\n}\n\nfunction flattenGroupMaps({\n  groupedValues,\n  parentIds,\n  isExpanded,\n  itemIndex,\n  expandedAll,\n  prevExpanded,\n  columnProps,\n}: {\n  groupedValues: GroupedData;\n  parentIds: string[];\n  isExpanded: boolean;\n  itemIndex: number;\n  expandedAll: boolean;\n  prevExpanded: Record<string, boolean>;\n  columnProps: ColumnProp[];\n}) {\n  const depth = parentIds.length;\n  const sourceWithGroups: DataType[] = [];\n  // collapse all groups in the beginning\n  let trimmed: Record<number, boolean> = {};\n\n  // index mapping\n  let oldNewIndexMap: Record<number, number> = {};\n\n  groupedValues.forEach((innerGroupedValues, groupId) => {\n    const levelIds = [...parentIds, groupId];\n    const mergedIds = levelIds.join(',');\n    const isGroupExpanded =\n      isExpanded && (!!expandedAll || !!prevExpanded[mergedIds]);\n    sourceWithGroups.push({\n      [PSEUDO_GROUP_ITEM]: groupId,\n      [GROUP_DEPTH]: depth,\n      [PSEUDO_GROUP_ITEM_ID]: JSON.stringify(levelIds),\n      [PSEUDO_GROUP_ITEM_VALUE]: mergedIds,\n      [GROUP_EXPANDED]: isGroupExpanded,\n      [GROUP_COLUMN_PROP]: columnProps[depth],\n      [columnProps[depth]]: groupId,\n    });\n    itemIndex += 1;\n    // If parent group is collapsed, mark all items as hidden\n    if (!isExpanded && depth) {\n      trimmed[itemIndex] = true;\n    }\n    if (Array.isArray(innerGroupedValues)) {\n      // This branch handles leaf nodes (actual data items)\n      innerGroupedValues.forEach(value => {\n        itemIndex += 1;\n        if (!isGroupExpanded) {\n          trimmed[itemIndex] = true; // Mark items as hidden if group is collapsed\n        }\n        oldNewIndexMap[value[GROUP_ORIGINAL_INDEX]] = itemIndex; // Keep track of new positions\n      });\n      sourceWithGroups.push(...innerGroupedValues);\n    } else {\n      // This branch handles nested groups (further subgroups)\n      const children = flattenGroupMaps({\n        groupedValues: innerGroupedValues,\n        parentIds: levelIds,\n        isExpanded: isGroupExpanded,\n        itemIndex,\n        expandedAll,\n        prevExpanded,\n        columnProps,\n      }); // Recursively process subgroups\n      sourceWithGroups.push(...children.source);\n      trimmed = { ...children.trimmed, ...trimmed };\n      oldNewIndexMap = { ...children.oldNewIndexMap, ...oldNewIndexMap };\n      itemIndex = children.itemIndex;\n    }\n  });\n  return {\n    source: sourceWithGroups,\n    oldNewIndexMap,\n    trimmed,\n    itemIndex,\n  };\n}\n\n/**\n * Gather data for grouping\n * @param array - flat data array\n * @param columnProps - ids of groups\n * @param expanded - potentially expanded items if present\n */\nexport function gatherGrouping(\n  array: DataType[],\n  columnProps: ColumnProp[],\n  {\n    prevExpanded = {},\n    expandedAll = false,\n    getGroupValue = getGroupValueDefault,\n  }: ExpandedOptions,\n) {\n  const groupedItems: GroupedData = new Map();\n  \n  array.forEach((item, originalIndex) => {\n    const groupLevelValues = columnProps.map(groupId => getGroupValue(item, groupId));\n    const lastLevelValue = groupLevelValues.pop();\n    let currentGroupLevel = groupedItems;\n    groupLevelValues.forEach(value => {\n      if (!currentGroupLevel.has(value)) {\n        currentGroupLevel.set(value, new Map());\n      }\n      currentGroupLevel = currentGroupLevel.get(value) as GroupedData;\n    });\n    if (!currentGroupLevel.has(lastLevelValue)) {\n      const groupItems: DataType[] = [];\n      currentGroupLevel.set(lastLevelValue, groupItems);\n    }\n    const lastLevelItems = currentGroupLevel.get(lastLevelValue) as DataType[];\n    lastLevelItems.push({\n      ...item,\n      [GROUP_ORIGINAL_INDEX]: originalIndex,\n    });\n  });\n\n  const groupingDepth = columnProps.length;\n\n  const { source: sourceWithGroups, trimmed, oldNewIndexMap } = flattenGroupMaps({\n    groupedValues: groupedItems,\n    parentIds: [],\n    isExpanded: true,\n    itemIndex: -1,\n    expandedAll,\n    prevExpanded,\n    columnProps\n  });\n\n  return {\n    sourceWithGroups, // updates source mirror\n    depth: groupingDepth, // largest depth for grouping\n    trimmed, // used for expand/collapse grouping values\n    oldNewIndexMap, // used for mapping old values to new\n  };\n}\n\nexport function getGroupingName(rgRow?: DataType) {\n  return rgRow?.[PSEUDO_GROUP_ITEM];\n}\n\ntype GroupingItem = {\n  [PSEUDO_GROUP_ITEM]: string;\n  [GROUP_EXPANDED]: boolean;\n  [PSEUDO_GROUP_ITEM_VALUE]: string;\n  [GROUP_DEPTH]: number;\n  [GROUP_COLUMN_PROP]: ColumnProp;\n};\n\nexport function isGrouping(rgRow?: DataType): rgRow is GroupingItem {\n  return typeof rgRow?.[PSEUDO_GROUP_ITEM] !== 'undefined';\n}\n\nexport function isGroupingColumn(column?: ColumnRegular) {\n  return typeof column?.[PSEUDO_GROUP_COLUMN] !== 'undefined';\n}\n\nexport function measureEqualDepth<T>(groupA: T[], groupB: T[]) {\n  const ln = groupA.length;\n  let i = 0;\n  for (; i < ln; i++) {\n    if (groupA[i] !== groupB[i]) {\n      return i;\n    }\n  }\n  return i;\n}\n\nexport function getParsedGroup(id: string) {\n  const parseGroup = JSON.parse(id);\n  // extra precaution and type safeguard\n  if (!Array.isArray(parseGroup)) {\n    return null;\n  }\n  return parseGroup;\n}\n\n// check if items is child of current clicked group\nexport function isSameGroup(\n  currentGroup: any[],\n  currentModel: DataType,\n  nextModel: DataType,\n) {\n  const nextGroup = getParsedGroup(nextModel[PSEUDO_GROUP_ITEM_ID]);\n  if (!nextGroup) {\n    return false;\n  }\n\n  const depth = measureEqualDepth(currentGroup, nextGroup);\n  return currentModel[GROUP_DEPTH] < depth;\n}\n", "/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nexport default baseSlice;\n", "import baseSlice from './_baseSlice.js';\nimport isIterateeCall from './_isIterateeCall.js';\nimport toInteger from './toInteger.js';\n\n/**\n * Creates a slice of `array` from `start` up to, but not including, `end`.\n *\n * **Note:** This method is used instead of\n * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n * returned.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction slice(array, start, end) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n    start = 0;\n    end = length;\n  }\n  else {\n    start = start == null ? 0 : toInteger(start);\n    end = end === undefined ? length : toInteger(end);\n  }\n  return baseSlice(array, start, end);\n}\n\nexport default slice;\n", "import { DSourceState, getSourceItem, getVisibleSourceItem } from '@store';\nimport {\n  Observable,\n  CELL_CLASS,\n  DISABLED_CLASS,\n  getCellRaw,\n  getCellData,\n} from '../../utils';\nimport { getRange } from '@store';\n\nimport { isGroupingColumn } from '../../plugins/groupingRow/grouping.service';\nimport slice from 'lodash/slice';\nimport {\n  DimensionCols,\n  DimensionRows,\n  RowDrag,\n  ColumnRegular,\n  DataType,\n  CellProps,\n  ColumnDataSchemaModel,\n  ColumnProp,\n  DataLookup,\n  DataFormat,\n  ChangedRange,\n  OldNewRangeMapping,\n  Cell,\n  RangeArea,\n  BeforeSaveDataDetails,\n  EditorCtr,\n  Editors,\n  CellTemplateProp,\n} from '@type';\nimport { JSXBase } from '@stencil/core/internal';\n\nexport type ColumnStores = {\n  [T in DimensionCols]: Observable<DSourceState<ColumnRegular, DimensionCols>>;\n};\nexport type RowStores = {\n  [T in DimensionRows]: Observable<DSourceState<DataType, DimensionRows>>;\n};\n\nexport function getCellEditor(\n  column: Pick<ColumnRegular, 'editor'> | undefined,\n  editors: Editors = {},\n): EditorCtr | undefined {\n  const editor = column?.editor;\n  if (!editor) {\n    return undefined;\n  }\n  // reference\n  if (typeof editor === 'string') {\n    return editors[editor];\n  }\n  return editor;\n}\n\nexport default class ColumnService {\n  private unsubscribe: { (): void }[] = [];\n  get columns(): ColumnRegular[] {\n    return getVisibleSourceItem(this.source);\n  }\n\n  hasGrouping = false;\n  type: DimensionCols;\n\n  constructor(\n    private dataStore: Observable<DSourceState<DataType, DimensionRows>>,\n    private source: Observable<DSourceState<ColumnRegular, DimensionCols>>,\n  ) {\n    this.unsubscribe.push(\n      source.onChange('source', s => this.checkGrouping(s)),\n    );\n    this.checkGrouping(source.get('source'));\n    this.type = source.get('type');\n  }\n\n  private checkGrouping(cols: ColumnRegular[]) {\n    for (let rgCol of cols) {\n      if (isGroupingColumn(rgCol)) {\n        this.hasGrouping = true;\n        return;\n      }\n      this.hasGrouping = false;\n    }\n  }\n\n  isReadOnly(r: number, c: number) {\n    const readOnly = this.columns[c]?.readonly;\n    if (typeof readOnly === 'function') {\n      const data = this.rowDataModel(r, c);\n      return readOnly(data);\n    }\n    return !!readOnly;\n  }\n\n  mergeProperties(\n    r: number,\n    c: number,\n    defaultProps: CellProps,\n    schemaModel: CellTemplateProp,\n  ): CellProps {\n    const props: CellProps = {\n      ...defaultProps,\n    };\n    props.class = {\n      ...(typeof props.class === 'string'\n        ? { [props.class]: true }\n        : props.class),\n      [CELL_CLASS]: true,\n      [DISABLED_CLASS]: this.isReadOnly(r, c),\n    };\n\n    const extra = schemaModel.column?.cellProperties?.(schemaModel);\n    if (!extra) {\n      return props;\n    }\n    return doPropMerge(props, extra);\n  }\n\n  getRowClass(r: number, prop: string): string {\n    const model = getSourceItem(this.dataStore, r) || {};\n    return model[prop] || '';\n  }\n\n  getSaveData(\n    rowIndex: number,\n    colIndex: number,\n    val?: string,\n  ): BeforeSaveDataDetails {\n    const data = this.rowDataModel(rowIndex, colIndex);\n    if (typeof val === 'undefined') {\n      val = getCellData(data.value);\n    }\n    return {\n      ...data,\n      val,\n    };\n  }\n\n  /**\n   * Get cell data model for given rowIndex and colIndex\n   * Used to pass data to editor/renderer\n   */\n  rowDataModel(rowIndex: number, colIndex: number): ColumnDataSchemaModel {\n    const column = this.columns[colIndex];\n    const prop = column?.prop;\n    const model = getSourceItem(this.dataStore, rowIndex) || {};\n    const type = this.dataStore.get('type');\n    return {\n      prop,\n      model,\n      data: this.dataStore.get('source'),\n      column,\n      rowIndex,\n      colIndex,\n      colType: this.type,\n      type,\n      value: getCellRaw(model, column),\n    };\n  }\n\n  getRangeData(\n    d: ChangedRange,\n    columns: ColumnRegular[],\n  ): {\n    changed: DataLookup;\n    mapping: OldNewRangeMapping;\n  } {\n    const changed: DataLookup = {};\n\n    // get original length sizes\n    const copyColLength = d.oldRange.x1 - d.oldRange.x + 1;\n    const copyRowLength = d.oldRange.y1 - d.oldRange.y + 1;\n    const mapping: OldNewRangeMapping = {};\n\n    // rows\n    for (\n      let rowIndex = d.newRange.y, i = 0;\n      rowIndex < d.newRange.y1 + 1;\n      rowIndex++, i++\n    ) {\n      // copy original data link\n      const oldRowIndex = d.oldRange.y + (i % copyRowLength);\n      const copyRow = getSourceItem(this.dataStore, oldRowIndex) || {};\n\n      // columns\n      for (\n        let colIndex = d.newRange.x, j = 0;\n        colIndex < d.newRange.x1 + 1;\n        colIndex++, j++\n      ) {\n        // check if old range area\n        if (\n          rowIndex >= d.oldRange.y &&\n          rowIndex <= d.oldRange.y1 &&\n          colIndex >= d.oldRange.x &&\n          colIndex <= d.oldRange.x1\n        ) {\n          continue;\n        }\n\n        // requested column beyond range\n        if (!this.columns[colIndex]) {\n          continue;\n        }\n        const prop = this.columns[colIndex]?.prop;\n        const copyColIndex = d.oldRange.x + (j % copyColLength);\n        const copyColumnProp = columns[copyColIndex].prop;\n\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][prop] = copyRow[copyColumnProp];\n          /** Generate mapping object */\n          if (!mapping[rowIndex]) {\n            mapping[rowIndex] = {};\n          }\n          mapping[rowIndex][prop] = {\n            colIndex: copyColIndex,\n            colProp: copyColumnProp,\n            rowIndex: oldRowIndex,\n          };\n        }\n      }\n    }\n    return {\n      changed,\n      mapping,\n    };\n  }\n\n  getTransformedDataToApply(\n    start: Cell,\n    data: DataFormat[][],\n  ): {\n    changed: DataLookup;\n    range: RangeArea | null;\n  } {\n    const changed: DataLookup = {};\n    const copyRowLength = data.length;\n    const colLength = this.columns.length;\n    const rowLength = this.dataStore.get('items').length;\n    // rows\n    let rowIndex = start.y;\n    let maxCol = 0;\n    for (\n      let i = 0;\n      rowIndex < rowLength && i < copyRowLength;\n      rowIndex++, i++\n    ) {\n      // copy original data link\n      const copyRow = data[i % copyRowLength];\n      const copyColLength = copyRow?.length || 0;\n      // columns\n      let colIndex = start.x;\n      for (\n        let j = 0;\n        colIndex < colLength && j < copyColLength;\n        colIndex++, j++\n      ) {\n        const p = this.columns[colIndex].prop;\n        const currentCol = j % colLength;\n\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][p] = copyRow[currentCol];\n        }\n      }\n      maxCol = Math.max(maxCol, colIndex - 1);\n    }\n    const range = getRange(start, {\n      y: rowIndex - 1,\n      x: maxCol,\n    });\n    return {\n      changed,\n      range,\n    };\n  }\n\n  getRangeStaticData(d: RangeArea, value: DataFormat): DataLookup {\n    const changed: DataLookup = {};\n\n    // rows\n    for (let rowIndex = d.y, i = 0; rowIndex < d.y1 + 1; rowIndex++, i++) {\n      // columns\n      for (let colIndex = d.x, j = 0; colIndex < d.x1 + 1; colIndex++, j++) {\n        // requested column beyond range\n        if (!this.columns[colIndex]) {\n          continue;\n        }\n        const p = this.columns[colIndex].prop;\n\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][p] = value;\n        }\n      }\n    }\n    return changed;\n  }\n\n  getRangeTransformedToProps(\n    d: RangeArea,\n    store: Observable<DSourceState<DataType, DimensionRows>>,\n  ) {\n    const area: {\n      prop: ColumnProp;\n      rowIndex: number;\n      colIndex: number;\n      model?: DataType;\n      colType: DimensionCols;\n      type: DimensionRows;\n    }[] = [];\n\n    const type = this.dataStore.get('type');\n    // rows\n    for (let rowIndex = d.y, i = 0; rowIndex < d.y1 + 1; rowIndex++, i++) {\n      // columns\n      for (let colIndex = d.x, j = 0; colIndex < d.x1 + 1; colIndex++, j++) {\n        const prop = this.columns[colIndex]?.prop;\n        area.push({\n          prop,\n          rowIndex,\n          colIndex,\n          model: getSourceItem(store, rowIndex),\n          type,\n          colType: this.type,\n        });\n      }\n    }\n    return area;\n  }\n\n  copyRangeArray(\n    range: RangeArea,\n    store: Observable<DSourceState<DataType, DimensionRows>>,\n  ) {\n    const cols = [...this.columns];\n    const props = slice(cols, range.x, range.x1 + 1).map(v => v.prop);\n    const toCopy: DataFormat[][] = [];\n    const mapping: { [rowIndex: number]: { [colProp: ColumnProp]: any } } = {};\n\n    // rows indexes\n    for (let i = range.y; i <= range.y1; i++) {\n      const rgRow: DataFormat[] = [];\n      mapping[i] = {};\n\n      // columns indexes\n      for (let prop of props) {\n        const item = getSourceItem(store, i);\n\n        // if no item - skip\n        if (!item) {\n          continue;\n        }\n        const val = item[prop];\n        rgRow.push(val);\n        mapping[i][prop] = val;\n      }\n\n      toCopy.push(rgRow);\n    }\n    return {\n      data: toCopy,\n      mapping,\n    };\n  }\n\n  destroy() {\n    this.unsubscribe.forEach(f => f());\n  }\n}\n\n/**\n * Checks if the given rowDrag is a service for dragging rows.\n */\nexport function isRowDragService(\n  rowDrag: RowDrag,\n  model: ColumnDataSchemaModel,\n): boolean {\n  if (typeof rowDrag === 'function') {\n    return rowDrag(model);\n  }\n  return !!rowDrag;\n}\n\nfunction mergeClasses(\n  class1: JSXBase.HTMLAttributes<HTMLElement>['class'] = {},\n  class2: JSXBase.HTMLAttributes<HTMLElement>['class'] = {},\n) {\n  if (typeof class1 === 'string') {\n    class1 = { [class1]: true };\n  }\n  if (typeof class2 === 'string') {\n    class2 = { [class2]: true };\n  }\n  return { ...class1, ...class2 };\n}\n\nexport function doPropMerge(existing: CellProps, extra: CellProps) {\n  // if className is provided - remove it from props it messing with stencil\n  if (extra.className) {\n    extra.class = mergeClasses(extra.class, extra.className);\n    delete extra.className;\n  }\n  let props: CellProps = { ...extra, ...existing };\n  // extend existing props\n  if (extra.class) {\n    props.class = mergeClasses(props.class, extra.class);\n  }\n  if (extra.style) {\n    props.style = { ...extra.style, ...props.style };\n  }\n  return props;\n}\n"],
  "mappings": "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",
  "names": ["collection"]
}
