import {
  createStore,
  getItemByPosition,
  setStore
} from "./chunk-52WLLNIP.js";

// node_modules/@revolist/revogrid/dist/esm/viewport.store-2mQugd8S.js
var LETTER_BLOCK_SIZE = 10;
var calculateRowHeaderSize = (itemsLength, rowHeaderColumn, minWidth = 50) => {
  return (rowHeaderColumn === null || rowHeaderColumn === void 0 ? void 0 : rowHeaderColumn.size) || Math.max((itemsLength.toString().length + 1) * LETTER_BLOCK_SIZE, minWidth);
};
function getUpdatedItemsByPosition(pos, items, realCount, virtualSize, dimension) {
  const activeItem = getItemByPosition(dimension, pos);
  const firstItem = getFirstItem(items);
  let toUpdate;
  if (firstItem) {
    let changedOffsetStart = activeItem.itemIndex - (firstItem.itemIndex || 0);
    if (changedOffsetStart) {
      toUpdate = recombineByOffset(Math.abs(changedOffsetStart), Object.assign(Object.assign({ positiveDirection: changedOffsetStart > -1 }, dimension), items));
    }
  }
  const maxSizeVirtualSize = getMaxVirtualSize(virtualSize, dimension.realSize, activeItem);
  if (toUpdate) {
    const extra = addMissingItems(activeItem, realCount, maxSizeVirtualSize, toUpdate, dimension);
    if (extra.length) {
      updateMissingAndRange(toUpdate.items, extra, toUpdate);
    }
  }
  if (!toUpdate) {
    const items2 = getItems({
      firstItemStart: activeItem.start,
      firstItemIndex: activeItem.itemIndex,
      origSize: dimension.originItemSize,
      maxSize: maxSizeVirtualSize,
      maxCount: realCount,
      sizes: dimension.sizes
    });
    toUpdate = {
      items: items2,
      start: 0,
      end: items2.length - 1
    };
  }
  return toUpdate;
}
function getMaxVirtualSize(virtualSize, realSize, activeItem) {
  return Math.min(virtualSize + (activeItem.end - activeItem.start), realSize);
}
function updateMissingAndRange(items, missing, range) {
  items.splice(range.end + 1, 0, ...missing);
  if (range.start >= range.end && !(range.start === range.end && range.start === 0)) {
    range.start += missing.length;
  }
  range.end += missing.length;
}
function addMissingItems(firstItem, realCount, virtualSize, existingCollection, dimension) {
  const lastItem = getLastItem(existingCollection);
  const items = getItems({
    sizes: dimension.sizes,
    firstItemStart: lastItem.end,
    firstItemIndex: lastItem.itemIndex + 1,
    origSize: dimension.originItemSize,
    maxSize: virtualSize - (lastItem.end - firstItem.start),
    maxCount: realCount
  });
  return items;
}
function getItems(opt, currentSize = 0) {
  const items = [];
  let index = opt.firstItemIndex;
  let size = currentSize;
  while (size <= opt.maxSize && index < opt.maxCount) {
    const newSize = getItemSize(index, opt.sizes, opt.origSize);
    items.push({
      start: opt.firstItemStart + size,
      end: opt.firstItemStart + size + newSize,
      itemIndex: index,
      size: newSize
    });
    size += newSize;
    index++;
  }
  return items;
}
function recombineByOffset(offset, data) {
  var _a, _b;
  const newItems = [...data.items];
  const itemsCount = newItems.length;
  let newRange = {
    start: data.start,
    end: data.end
  };
  if (offset > itemsCount) {
    return void 0;
  }
  if (data.positiveDirection) {
    let lastItem = getLastItem(data);
    let i = newRange.start;
    const length = i + offset;
    for (; i < length; i++) {
      const newIndex = lastItem.itemIndex + 1;
      const size = getItemSize(newIndex, data.sizes, data.originItemSize);
      if (lastItem.end + size > data.realSize) {
        break;
      }
      let newEnd = i % itemsCount;
      if (!newItems[newEnd]) {
        throw new Error("incorrect index");
      }
      newItems[newEnd] = lastItem = {
        start: lastItem.end,
        end: lastItem.end + size,
        itemIndex: newIndex,
        size
      };
      newRange.start++;
      newRange.end = newEnd;
    }
  } else {
    let firstItem = getFirstItem(data);
    const end = newRange.end;
    for (let i = 0; i < offset; i++) {
      const newIndex = ((_a = firstItem === null || firstItem === void 0 ? void 0 : firstItem.itemIndex) !== null && _a !== void 0 ? _a : 0) - 1;
      const size = getItemSize(newIndex, data.sizes, data.originItemSize);
      let newStart = end - i;
      newStart = (newStart < 0 ? itemsCount + newStart : newStart) % itemsCount;
      if (!newItems[newStart]) {
        console.error("incorrect index");
        break;
      }
      const firstItemStart = (_b = firstItem === null || firstItem === void 0 ? void 0 : firstItem.start) !== null && _b !== void 0 ? _b : 0;
      newItems[newStart] = firstItem = {
        start: firstItemStart - size,
        end: firstItemStart,
        itemIndex: newIndex,
        size
      };
      newRange.start = newStart;
      newRange.end--;
    }
  }
  const range = {
    start: (newRange.start < 0 ? itemsCount + newRange.start : newRange.start) % itemsCount,
    end: (newRange.end < 0 ? itemsCount + newRange.end : newRange.end) % itemsCount
  };
  return Object.assign({ items: newItems }, range);
}
function getItemSize(index, sizes, origSize = 0) {
  if (sizes && sizes[index]) {
    return sizes[index];
  }
  return origSize;
}
function isActiveRange(pos, realSize, first, last) {
  if (!first || !last) {
    return false;
  }
  return pos >= first.start && pos <= first.end || pos > first.end && last.end === realSize;
}
function isActiveRangeOutsideLastItem(pos, virtualSize, firstItem, lastItem) {
  var _a;
  if (!firstItem) {
    return false;
  }
  return virtualSize + pos > ((_a = lastItem === null || lastItem === void 0 ? void 0 : lastItem.end) !== null && _a !== void 0 ? _a : 0);
}
function getFirstItem(s) {
  return s.items[s.start];
}
function getLastItem(s) {
  return s.items[s.end];
}
function setItemSizes(vpItems, initialIndex, size, lastCoordinate) {
  const items = [...vpItems];
  const count = items.length;
  let pos = lastCoordinate;
  let i = 0;
  let start = initialIndex;
  if (!count) {
    return [];
  }
  while (i < count) {
    const item = items[start];
    item.start = pos;
    item.size = size;
    item.end = item.start + size;
    pos = item.end;
    start++;
    i++;
    if (start === count) {
      start = 0;
    }
  }
  return items;
}
function initialState() {
  return {
    // virtual item information per rendered item
    items: [],
    // virtual dom item order to render
    start: 0,
    end: 0,
    // size of virtual viewport in px
    virtualSize: 0,
    // total number of items
    realCount: 0,
    // size of viewport in px
    clientSize: 0
  };
}
var ViewportStore = class {
  get lastCoordinate() {
    return this.lastKnownScroll;
  }
  set lastCoordinate(value) {
    this.lastKnownScroll = value;
  }
  constructor(type) {
    this.type = type;
    this.lastKnownScroll = 0;
    this.store = createStore(initialState());
  }
  /**
   * Render viewport based on coordinate
   * It's the main method for draw
   * Use force if you want to re-render viewport
   */
  setViewPortCoordinate(position, dimension, force = false) {
    const viewportSize = this.store.get("virtualSize");
    if (!viewportSize) {
      return;
    }
    const frameOffset = 1;
    const singleOffsetInPx = dimension.originItemSize * frameOffset;
    const outsize = singleOffsetInPx * 2;
    const virtualSize = viewportSize + outsize;
    let maxCoordinate = 0;
    if (dimension.realSize > viewportSize) {
      maxCoordinate = dimension.realSize - viewportSize - singleOffsetInPx;
    }
    let pos = position;
    if (pos < 0) {
      pos = 0;
    } else if (pos > maxCoordinate) {
      pos = maxCoordinate;
    }
    this.lastCoordinate = pos;
    pos -= singleOffsetInPx;
    pos = pos < 0 ? 0 : pos < maxCoordinate ? pos : maxCoordinate;
    let allItems;
    if (force) {
      allItems = {
        items: [],
        start: 0,
        end: 0
      };
    } else {
      allItems = this.getItems();
    }
    const firstItem = getFirstItem(allItems);
    const lastItem = getLastItem(allItems);
    let toUpdate = {};
    if (!isActiveRange(pos, dimension.realSize, firstItem, lastItem)) {
      toUpdate = Object.assign(Object.assign({}, toUpdate), getUpdatedItemsByPosition(pos, allItems, this.store.get("realCount"), virtualSize, dimension));
      this.setViewport(Object.assign({}, toUpdate));
    } else if (isActiveRangeOutsideLastItem(pos, virtualSize, firstItem, lastItem)) {
      const items = [...allItems.items];
      const missing = addMissingItems(firstItem, this.store.get("realCount"), virtualSize + pos - firstItem.start, allItems, {
        sizes: dimension.sizes,
        originItemSize: dimension.originItemSize
      });
      if (missing.length) {
        const range = {
          start: this.store.get("start"),
          end: this.store.get("end")
        };
        updateMissingAndRange(items, missing, range);
        toUpdate = Object.assign(Object.assign(Object.assign({}, toUpdate), { items: [...items] }), range);
        this.setViewport(Object.assign({}, toUpdate));
      }
    }
  }
  /**
   * Set sizes for existing items
   */
  setOriginalSizes(size) {
    const items = this.store.get("items");
    const count = items.length;
    if (!count) {
      return;
    }
    setStore(this.store, {
      items: setItemSizes(items, this.store.get("start"), size, this.lastCoordinate)
    });
  }
  getItems() {
    return {
      items: this.store.get("items"),
      start: this.store.get("start"),
      end: this.store.get("end")
    };
  }
  setViewport(data) {
    if (typeof data.realCount === "number" || typeof data.virtualSize === "number") {
      data = Object.assign(Object.assign({}, data), { items: data.items || [] });
    }
    setStore(this.store, data);
  }
};

export {
  calculateRowHeaderSize,
  getUpdatedItemsByPosition,
  updateMissingAndRange,
  addMissingItems,
  getItems,
  recombineByOffset,
  isActiveRange,
  isActiveRangeOutsideLastItem,
  getFirstItem,
  getLastItem,
  setItemSizes,
  ViewportStore
};
/*! Bundled license information:

@revolist/revogrid/dist/esm/viewport.store-2mQugd8S.js:
  (*!
   * Built by Revolist OU ❤️
   *)
*/
//# sourceMappingURL=chunk-YXORL5PL.js.map
