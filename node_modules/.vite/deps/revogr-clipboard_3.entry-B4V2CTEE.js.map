{
  "version": 3,
  "sources": ["../../@revolist/revogrid/dist/esm/src/components/clipboard/revogr-clipboard.tsx", "../../@revolist/revogrid/dist/esm/src/components/editors/revogr-edit-style.scss?tag=revogr-edit", "../../@revolist/revogrid/dist/esm/src/components/editors/revogr-edit.tsx", "../../@revolist/revogrid/dist/esm/src/components/order/order-row.service.ts", "../../@revolist/revogrid/dist/esm/src/components/order/revogr-order-editor.tsx"],
  "sourcesContent": ["import {\n  Component,\n  Listen,\n  Method,\n  Event,\n  EventEmitter,\n  Prop,\n} from '@stencil/core';\nimport { DataFormat } from '@type';\n/**\n * This Clipboard provides functionality for handling clipboard events in a web application.\n */\n@Component({ tag: 'revogr-clipboard' })\nexport class Clipboard {\n  /**\n   * If readonly mode - disabled Paste event\n   */\n  @Prop() readonly: boolean;\n\n  /**\n   * Paste 1. Fired before paste applied to the grid\n   * defaultPrevented - if true, paste will be canceled\n   */\n  @Event({ eventName: 'beforepaste' }) beforePaste: EventEmitter<{\n    raw: string;\n    isHTML: boolean;\n    event: ClipboardEvent;\n    dataText: string;\n  }>;\n\n  /**\n   * Paste 2. Fired before paste applied to the grid and after data parsed\n   */\n  @Event({ eventName: 'beforepasteapply' })\n  beforePasteApply: EventEmitter<{\n    raw: string;\n    parsed: string[][];\n    event: ClipboardEvent;\n  }>;\n\n  /**\n   * Paste 3. Internal method. When data region is ready pass it to the top.\n   * @property {string[][]} data - data to paste\n   * @property {boolean} defaultPrevented - if true, paste will be canceled\n   */\n  @Event({ eventName: 'pasteregion' })\n  pasteRegion: EventEmitter<string[][]>;\n\n  /**\n   * Paste 4. Fired after paste applied to the grid\n   * defaultPrevented - if true, paste will be canceled\n   */\n  @Event({ eventName: 'afterpasteapply' }) afterPasteApply: EventEmitter<{\n    raw: string;\n    parsed: string[][];\n    event: ClipboardEvent;\n  }>;\n\n  /**\n   * Cut 1. Fired before cut triggered\n   * defaultPrevented - if true, cut will be canceled\n   */\n  @Event({ eventName: 'beforecut' }) beforeCut: EventEmitter<{\n    event: ClipboardEvent;\n  }>;\n\n  /**\n   * Cut 2. Clears region when cut is done\n   */\n  @Event({ eventName: 'clearregion' }) clearRegion: EventEmitter<DataTransfer>;\n\n  /**\n   * Copy 1. Fired before copy triggered\n   * defaultPrevented - if true, copy will be canceled\n   */\n  @Event({ eventName: 'beforecopy' }) beforeCopy: EventEmitter<{\n    event: ClipboardEvent;\n  }>;\n\n  /**\n   * Copy Method 1. Fired before copy applied to the clipboard from outside.\n   * defaultPrevented - if true, copy will be canceled\n   */\n  @Event({ eventName: 'beforecopyapply' }) beforeCopyApply: EventEmitter<{\n    event: DataTransfer;\n    data?: string[][];\n  }>;\n\n  /**\n   * Copy 2. Fired when region copied\n   * defaultPrevented - if true, copy will be canceled\n   */\n  @Event({ eventName: 'copyregion' })\n  copyRegion: EventEmitter<DataTransfer>;\n\n  @Listen('paste', { target: 'document' }) onPaste(e: ClipboardEvent) {\n    // if readonly do nothing\n    if (this.readonly) {\n      return;\n    }\n    const clipboardData = this.getData(e);\n    const isHTML = (clipboardData?.types.indexOf('text/html') || -1) > -1;\n    const data = (isHTML\n      ? clipboardData?.getData('text/html')\n      : clipboardData?.getData('text')) || '';\n    const dataText = clipboardData?.getData('text') || '';\n\n    const beforePaste = this.beforePaste.emit({\n      raw: data,\n      dataText,\n      isHTML,\n      event: e,\n    });\n\n    if (beforePaste.defaultPrevented) {\n      return;\n    }\n\n    let parsedData: string[][];\n    // if html, then search for table if no table fallback to regular text parsing\n    if (beforePaste.detail.isHTML) {\n      const table = this.htmlParse(beforePaste.detail.raw);\n      // fallback to text if not possible to parse as html\n      parsedData = table || this.textParse(dataText || '');\n    } else {\n      parsedData = this.textParse(beforePaste.detail.raw);\n    }\n    const beforePasteApply = this.beforePasteApply.emit({\n      raw: data,\n      parsed: parsedData,\n      event: e,\n    });\n    if (beforePasteApply.defaultPrevented) {\n      return;\n    }\n    this.pasteRegion.emit(beforePasteApply.detail.parsed);\n    // post paste action\n    const afterPasteApply = this.afterPasteApply.emit({\n      raw: data,\n      parsed: parsedData,\n      event: e,\n    });\n    // keep default behavior if needed\n    if (afterPasteApply.defaultPrevented) {\n      return;\n    }\n    e.preventDefault();\n  }\n\n  /**\n   * Listen to copy event and emit copy region event\n   */\n  @Listen('copy', { target: 'document' }) copyStarted(e: ClipboardEvent) {\n    const beforeCopy = this.beforeCopy.emit({\n      event: e,\n    });\n    if (beforeCopy.defaultPrevented) {\n      return;\n    }\n    const data = this.getData(beforeCopy.detail.event);\n    this.copyRegion.emit(data || undefined);\n    e.preventDefault();\n  }\n\n  /**\n   * Listen to copy event and emit copy region event\n   */\n  @Listen('cut', { target: 'document' }) cutStarted(e: ClipboardEvent) {\n    const beforeCut = this.beforeCut.emit({\n      event: e,\n    });\n    if (beforeCut.defaultPrevented) {\n      return;\n    }\n    const data = this.getData(beforeCut.detail.event);\n    this.copyStarted(e);\n\n    // if readonly do nothing\n    if (this.readonly) {\n      return;\n    }\n\n    this.clearRegion.emit(data || undefined);\n    e.preventDefault();\n  }\n\n  @Method() async doCopy(e: DataTransfer, data?: DataFormat[][]) {\n    const beforeCopyApply = this.beforeCopyApply.emit({\n      event: e,\n      data,\n    });\n    if (beforeCopyApply.defaultPrevented) {\n      return;\n    }\n    const parsed = data ? this.parserCopy(data) : '';\n    e.setData('text/plain', parsed);\n  }\n\n  parserCopy(data: DataFormat[][]) {\n    return data.map(rgRow => rgRow.join('\\t')).join('\\n');\n  }\n\n  private textParse(data: string) {\n    const result: string[][] = [];\n    const rows = data.split(/\\r\\n|\\n|\\r/);\n    for (let y in rows) {\n      result.push(rows[y].split('\\t'));\n    }\n    return result;\n  }\n\n  private htmlParse(data: string) {\n    const result: string[][] = [];\n    const fragment = document.createRange().createContextualFragment(data);\n    const table = fragment.querySelector('table');\n    if (!table) {\n      return null;\n    }\n    for (const rgRow of Array.from(table.rows)) {\n      result.push(Array.from(rgRow.cells).map(cell => cell.innerText));\n    }\n    return result;\n  }\n\n  private getData(e: ClipboardEvent) {\n    return (\n      e.clipboardData ||\n      (window as unknown as { clipboardData: DataTransfer | null })\n        ?.clipboardData\n    );\n  }\n}\n", "revogr-edit {\n  display: block;\n  position: absolute;\n  background-color: #fff;\n\n  input {\n    height: 100%;\n    width: 100%;\n    box-sizing: border-box;\n  }\n\n  revo-dropdown {\n    height: 100%;\n\n    &.shrink {\n      fieldset legend > span {\n        display: none;\n      }\n    }\n  }\n}\n", "import {\n  Component,\n  Event,\n  EventEmitter,\n  Prop,\n  h,\n  Element,\n  Host,\n  Method,\n} from '@stencil/core';\nimport { EDIT_INPUT_WR } from '../../utils/consts';\nimport { TextEditor } from './text-editor';\nimport { ColumnDataSchemaModel } from '@type';\nimport {\n  EditCell,\n  EditorCtr,\n  SaveDataDetails,\n  EditorBase,\n} from '@type';\n\nimport { isEditorCtrConstructible } from './edit.utils';\n\n/**\n * Represents a cell editor in a grid.\n * It manages the editing of cells by handling events, saving data, rendering the editor UI,\n * and managing the lifecycle of the editor instance.\n */\n@Component({\n  tag: 'revogr-edit',\n  styleUrl: 'revogr-edit-style.scss',\n})\nexport class RevoEdit {\n  /**\n   * Cell to edit data.\n   */\n  @Prop() editCell: EditCell;\n\n  /**\n   * Column data for editor.\n   */\n  @Prop() column: ColumnDataSchemaModel | null;\n  /**\n   * Custom editors register\n   */\n  @Prop() editor: EditorCtr | null;\n\n  /**\n   * Save on editor close. Defines if data should be saved on editor close.\n   */\n  @Prop() saveOnClose = false;\n  /**\n   * Additional data to pass to renderer\n   */\n  @Prop() additionalData: any;\n\n  /**\n   * Cell edit event initiator, first in the cellEdit event chain\n   */\n  @Event({ eventName: 'celleditinit' }) cellEdit: EventEmitter<SaveDataDetails>;\n\n  /**\n   * Close editor event\n   * pass true if requires focus next\n   */\n  @Event({ eventName: 'closeedit' }) closeEdit: EventEmitter<\n    boolean | undefined\n  >;\n\n  /** Edit session editor */\n  @Element() element: HTMLElement;\n  private currentEditor: EditorBase | null = null;\n  private preventSaveOnClose = false;\n\n  /**\n   * Cancel pending changes flag. Editor will be closed without autosave.\n   */\n  @Method() async cancelChanges() {\n    this.preventSaveOnClose = true;\n  }\n\n  /**\n   * Before editor got disconnected.\n   * Can be triggered multiple times before actual disconnect.\n   */\n  @Method() async beforeDisconnect() {\n    this.currentEditor?.beforeDisconnect?.();\n  }\n\n  onAutoSave() {\n    this.preventSaveOnClose = true;\n    const val = this.currentEditor?.getValue?.();\n    // For Editor plugin internal usage.\n    // When you want to prevent save and use custom save of your own.\n    if (this.currentEditor?.beforeAutoSave) {\n      const canSave = this.currentEditor.beforeAutoSave(val);\n      if (canSave === false) {\n        return;\n      }\n    }\n    this.onSave(val, true);\n  }\n\n  /**\n   * Callback triggered when cell editor saved.\n   * Closes editor when called.\n   * @param preventFocus - if true, editor will not be closed & next cell will not be focused.\n   */\n  onSave(val?: any, preventFocus?: boolean) {\n    this.preventSaveOnClose = true;\n    if (this.editCell) {\n      this.cellEdit.emit({\n        rgCol: this.editCell.x,\n        rgRow: this.editCell.y,\n        type: this.editCell.type,\n        prop: this.editCell.prop,\n        val,\n        preventFocus,\n      });\n    }\n  }\n\n  componentWillRender() {\n    // Active editor present and not yet closed.\n    if (this.currentEditor || !this.column) {\n      return;\n    }\n    this.preventSaveOnClose = false;\n\n    // Custom editor usage.\n    // Start with TextEditor (editors/text.tsx) for Custom editor.\n    // It can be class or function\n    if (this.editor) {\n      // if editor is constructible\n      if (isEditorCtrConstructible(this.editor)) {\n        this.currentEditor = new this.editor(\n          this.column,\n          // save callback\n          (e, preventFocus) => {\n            this.onSave(e, preventFocus);\n          },\n          // cancel callback\n          focusNext => {\n            this.preventSaveOnClose = true;\n            this.closeEdit.emit(focusNext);\n          },\n        );\n      // if editor is function\n      } else {\n        this.currentEditor = this.editor(\n          this.column,\n          // save callback\n          (e, preventFocus) => {\n            this.onSave(e, preventFocus);\n          },\n          // cancel callback\n          focusNext => {\n            this.preventSaveOnClose = true;\n            this.closeEdit.emit(focusNext);\n          },\n        );\n      }\n      return;\n    }\n    // Default text editor usage\n    this.currentEditor = new TextEditor(this.column, (e, preventFocus) =>\n      this.onSave(e, preventFocus),\n    );\n  }\n\n  componentDidRender() {\n    if (!this.currentEditor) {\n      return;\n    }\n    this.currentEditor.element = this.element.firstElementChild;\n    this.currentEditor.componentDidRender?.();\n  }\n\n  disconnectedCallback() {\n    if (this.saveOnClose) {\n      // Can not be cancelled by `preventSaveOnClose` prop.\n      // Editor requires `getValue` to be able to save.\n      if (!this.preventSaveOnClose) {\n        this.onAutoSave();\n      }\n    }\n\n    this.preventSaveOnClose = false;\n    if (!this.currentEditor) {\n      return;\n    }\n\n    this.currentEditor.disconnectedCallback?.();\n    this.currentEditor.element = null;\n    this.currentEditor = null;\n  }\n\n  render() {\n    if (this.currentEditor) {\n      this.currentEditor.editCell = this.editCell;\n      return (\n        <Host class={EDIT_INPUT_WR}>\n          {this.currentEditor.render(h, this.additionalData)}\n        </Host>\n      );\n    }\n    return '';\n  }\n}\n", "import { getItemByPosition } from '@store';\nimport { DimensionSettingsState, PositionItem, Cell } from '@type';\n\ntype EventData = { el: HTMLElement; rows: DimensionSettingsState; cols: DimensionSettingsState };\ninterface Config {\n  positionChanged(from: number, to: number): void;\n}\n\nexport default class RowOrderService {\n  private currentCell: Cell | null = null;\n  private previousRow: number | null = null;\n\n  constructor(private config: Config) {}\n\n  /** Drag finished, calculate and apply changes */\n  endOrder(e: MouseEvent, data: EventData) {\n    if (this.currentCell === null) {\n      return;\n    }\n    const newRow = this.getCell(e, data);\n\n    // if position changed\n    if (newRow.y !== this.currentCell.y) {\n      // rgRow dragged out table\n      if (newRow.y < 0) {\n        newRow.y = 0;\n      }\n      // rgRow dragged to the top\n      else if (newRow.y < this.currentCell.y) {\n        newRow.y++;\n      }\n      this.config.positionChanged(this.currentCell.y, newRow.y);\n    }\n    this.clear();\n  }\n\n  /** Drag started, reserve initial cell for farther use */\n  startOrder(e: MouseEvent, data: EventData): Cell {\n    this.currentCell = this.getCell(e, data);\n    return this.currentCell;\n  }\n\n  move(y: number, data: EventData): PositionItem | null {\n    const rgRow = this.getRow(y, data);\n    // if rgRow same as previous or below range (-1 = 0) do nothing\n    if (this.previousRow === rgRow.itemIndex || rgRow.itemIndex < -1) {\n      return null;\n    }\n    this.previousRow = rgRow.itemIndex;\n    return rgRow;\n  }\n\n  /** Drag stopped, probably cursor outside of document area */\n  clear() {\n    this.currentCell = null;\n    this.previousRow = null;\n  }\n\n  /** Calculate cell based on x, y position */\n  getRow(y: number, { el, rows }: EventData): PositionItem {\n    const { top } = el.getBoundingClientRect();\n    const topRelative = y - top;\n    const rgRow = getItemByPosition(rows, topRelative);\n    const absolutePosition = {\n      itemIndex: rgRow.itemIndex,\n      start: rgRow.start + top,\n      end: rgRow.end + top,\n    };\n    return absolutePosition;\n  }\n\n  /** Calculate cell based on x, y position */\n  getCell({ x, y }: Cell, { el, rows, cols }: EventData): Cell {\n    const { top, left } = el.getBoundingClientRect();\n    const topRelative = y - top;\n    const leftRelative = x - left;\n    const rgRow = getItemByPosition(rows, topRelative);\n    const rgCol = getItemByPosition(cols, leftRelative);\n    return { x: rgCol.itemIndex, y: rgRow.itemIndex };\n  }\n}\n", "import { Component, Method, Event, EventEmitter, Prop } from '@stencil/core';\nimport debounce from 'lodash/debounce';\n\nimport { type DSourceState, getSourceItem } from '@store';\nimport { DRAGG_TEXT } from '../../utils/consts';\nimport RowOrderService from './order-row.service';\nimport type {\n  DimensionRows,\n  DataType,\n  DimensionSettingsState,\n  DragStartEvent,\n  PositionItem,\n  Cell,\n  RowDragStartDetails,\n} from '@type';\nimport type { Observable } from '../../utils';\n\n/**\n * Component for handling row order editor.\n */\n@Component({ tag: 'revogr-order-editor' })\nexport class OrderEditor {\n  // #region Properties\n  /** Parent element */\n  @Prop() parent: HTMLElement;\n  /** Dimension settings Y */\n  @Prop() dimensionRow: Observable<DimensionSettingsState>;\n  /** Dimension settings X */\n  @Prop() dimensionCol: Observable<DimensionSettingsState>;\n\n  /** Static stores, not expected to change during component lifetime */\n  @Prop() dataStore: Observable<DSourceState<DataType, DimensionRows>>;\n\n  @Prop() rowType: DimensionRows;\n  // #endregion\n\n  // #region Events\n  /** Row drag started */\n  @Event({ eventName: 'rowdragstartinit', cancelable: true })\n  rowDragStart: EventEmitter<RowDragStartDetails>;\n\n  /** Row drag ended started */\n  @Event({ eventName: 'rowdragendinit' })\n  rowDragEnd: EventEmitter<{ rowType: DimensionRows }>;\n\n  /** Row move started */\n  @Event({ eventName: 'rowdragmoveinit', cancelable: true })\n  rowDrag: EventEmitter<PositionItem & { rowType: DimensionRows }>;\n\n  /** Row mouse move started */\n  @Event({ eventName: 'rowdragmousemove', cancelable: true })\n  rowMouseMove: EventEmitter<Cell & { rowType: DimensionRows }>;\n\n  /** Row dragged, new range ready to be applied */\n  @Event({ eventName: 'rowdropinit', cancelable: true })\n  rowDropped: EventEmitter<{\n    from: number;\n    to: number;\n    rowType: DimensionRows;\n  }>;\n\n  /** Row drag ended finished. Time to apply data */\n  @Event({ eventName: 'roworderchange' })\n  rowOrderChange: EventEmitter<{\n    from: number;\n    to: number;\n    rowType: DimensionRows;\n  }>;\n\n  // #endregion\n\n  // #region Private\n  private rowOrderService: RowOrderService;\n  private events: {\n    name: keyof DocumentEventMap;\n    listener: (e: MouseEvent) => void;\n  }[] = [];\n  private rowMoveFunc = debounce((y: number) => {\n    const rgRow = this.rowOrderService.move(y, this.getData());\n    if (rgRow !== null) {\n      this.rowDrag.emit({\n        ...rgRow,\n        rowType: this.rowType,\n      });\n    }\n  }, 5);\n  // #endregion\n\n  // #region Methods\n  @Method() async dragStart(e: DragStartEvent) {\n    e.originalEvent.preventDefault();\n\n    // extra check if previous ended\n    if (this.events.length) {\n      this.clearOrder();\n    }\n\n    const data = this.getData();\n    const cell = this.rowOrderService.startOrder(e.originalEvent, data);\n    const pos = this.rowOrderService.getRow(e.originalEvent.y, data);\n    const dragStartEvent = this.rowDragStart.emit({\n      cell,\n      text: DRAGG_TEXT,\n      pos,\n      event: e.originalEvent,\n      rowType: this.rowType,\n      model: getSourceItem(this.dataStore, pos.itemIndex),\n    });\n    if (dragStartEvent.defaultPrevented) {\n      return;\n    }\n\n    const moveMove = (e: MouseEvent) => this.move(e);\n    const mouseUp = (e: MouseEvent) => this.endOrder(e);\n    const mouseLeave = () => this.clearOrder();\n\n    this.events.push(\n      {\n        name: 'mousemove',\n        listener: moveMove,\n      },\n      {\n        name: 'mouseup',\n        listener: mouseUp,\n      },\n      {\n        name: 'mouseleave',\n        listener: mouseLeave,\n      },\n    );\n    document.addEventListener('mousemove', moveMove);\n    // Action finished inside of the document\n    document.addEventListener('mouseup', mouseUp);\n    document.addEventListener('mouseleave', mouseLeave);\n  }\n\n  @Method() async endOrder(e: MouseEvent) {\n    this.rowOrderService.endOrder(e, this.getData());\n    this.clearOrder();\n  }\n\n  @Method() async clearOrder() {\n    this.rowOrderService.clear();\n    this.events.forEach(v => document.removeEventListener(v.name, v.listener));\n    this.events.length = 0;\n    this.rowDragEnd.emit({ rowType: this.rowType });\n  }\n  // #endregion\n\n  move({ x, y }: { x: number; y: number }) {\n    this.rowMouseMove.emit({ x, y, rowType: this.rowType });\n    this.rowMoveFunc(y);\n  }\n\n  connectedCallback() {\n    this.rowOrderService = new RowOrderService({\n      positionChanged: (from: number, to: number) => {\n        const dropEvent = this.rowDropped.emit({\n          from,\n          to,\n          rowType: this.rowType,\n        });\n        if (dropEvent.defaultPrevented) {\n          return;\n        }\n        this.rowOrderChange.emit(dropEvent.detail);\n      },\n    });\n  }\n\n  private getData() {\n    return {\n      el: this.parent,\n      rows: this.dimensionRow.state,\n      cols: this.dimensionCol.state,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["e"]
}
