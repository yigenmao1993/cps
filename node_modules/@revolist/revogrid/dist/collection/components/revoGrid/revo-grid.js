/*!
 * Built by Revolist OU ❤️
 */
import { h, Host, } from "@stencil/core";
import ColumnDataProvider from "../../services/column.data.provider";
import { DataProvider } from "../../services/data.provider";
import { getVisibleSourceItem, rowTypes } from "../../store/index";
import DimensionProvider from "../../services/dimension.provider";
import ViewportProvider from "../../services/viewport.provider";
import ThemeService from "../../themeManager/theme.service";
import { timeout } from "../../utils";
import { AutoSizeColumnPlugin, } from "../../plugins/column.auto-size.plugin";
import { FilterPlugin, } from "../../plugins/filter/filter.plugin";
import { SortingPlugin } from "../../plugins/sorting/sorting.plugin";
import { ExportFilePlugin } from "../../plugins/export/export.plugin";
import { GroupingRowPlugin } from "../../plugins/groupingRow/grouping.row.plugin";
import ViewportService from "./viewport.service";
import { DATA_SLOT, HEADER_SLOT } from "./viewport.helpers";
import GridScrollingService from "./viewport.scrolling.service";
import { SelectionStoreConnector } from "../../services/selection.store.connector";
import OrderRenderer from "../order/order-renderer";
import { StretchColumn, isStretchPlugin, } from "../../plugins/column.stretch.plugin";
import { rowDefinitionByType, rowDefinitionRemoveByType } from "./grid.helpers";
import { ColumnMovePlugin } from "../../plugins/moveColumn/column.drag.plugin";
import { getPropertyFromEvent } from "../../utils/events";
import { isMobileDevice } from "../../utils/mobile";
import { getColumnByProp, getColumns } from "../../utils/column.utils";
import { WCAGPlugin } from "../../plugins/wcag";
import { PluginService } from "./plugin.service";
import { RTLPlugin } from "../../plugins/rtl/rtl.plugin";
/**
 * Revogrid - High-performance, customizable grid library for managing large datasets.
 * ### Events guide
 *
 * For a comprehensive events guide, check the [Events API Page](/guide/api/events).
 * All events propagate to the root level of the grid. [Dependency tree](#Dependencies).
 *
 * ### Type definitions
 *
 * Read [type definition file](https://github.com/revolist/revogrid/blob/master/src/interfaces.d.ts) for the full interface information.
 *
 * All complex property types such as `ColumnRegular`, `ColumnProp`, `ColumnDataSchemaModel` can be found there.
 *
 * ### HTMLRevoGridElement
 *
 * @slot data-{column-type}-{row-type}. @example data-rgCol-rgRow - main data slot. Applies extra elements in <revogr-data />.
 * @slot focus-{column-type}-{row-type}. @example focus-rgCol-rgRow - focus layer for main data. Applies extra elements in <revogr-focus />.
 * @slot viewport - Viewport slot.
 * @slot header - Header slot.
 * @slot footer - Footer slot.
*/
export class RevoGridComponent {
    constructor() {
        /**
         * Defines how many rows/columns should be rendered outside visible area.
         */
        this.frameSize = 1;
        /**
         * Indicates default rgRow size.
         * By default 0, means theme package size will be applied
         *
         * Alternatively you can use `rowSize` to reset viewport
         */
        this.rowSize = 0;
        /** Indicates default column size. */
        this.colSize = 100;
        /** When true, user can range selection. */
        this.range = false;
        /** When true, grid in read only mode. */
        this.readonly = false;
        /** When true, columns are resizable. */
        this.resize = false;
        /** When true cell focus appear. */
        this.canFocus = true;
        /** When true enable clipboard. */
        this.useClipboard = true;
        /**
         * Columns - defines an array of grid columns.
         * Can be column or grouped column.
         */
        this.columns = [];
        /**
         * Source - defines main data source.
         * Can be an Object or 2 dimensional array([][]);
         * Keys/indexes referenced from columns Prop.
         */
        this.source = [];
        /** Pinned top Source: {[T in ColumnProp]: any} - defines pinned top rows data source. */
        this.pinnedTopSource = [];
        /** Pinned bottom Source: {[T in ColumnProp]: any} - defines pinned bottom rows data source. */
        this.pinnedBottomSource = [];
        /** Custom row properies to be applied. See `RowDefinition` for more info. */
        this.rowDefinitions = [];
        /** Custom editors register. */
        this.editors = {};
        /**
         * Apply changes in editor when closed except 'Escape' cases.
         * If custom editor in use method getValue required.
         * Check interfaces.d.ts `EditorBase` for more info.
         */
        this.applyOnClose = false;
        /**
         * Custom grid plugins. Can be added or removed at runtime.
         * Every plugin should be inherited from BasePlugin class.
         *
         * For more details check [Plugin guide](https://rv-grid.com/guide/plugin/)
         */
        this.plugins = [];
        /**
         * Column Types Format.
         * Every type represent multiple column properties.
         * Types will be merged but can be replaced with column properties.
         * Types were made as separate objects to be reusable per multiple columns.
         */
        this.columnTypes = {};
        /** Theme name. */
        this.theme = 'default';
        /**
         * Row class property mapping.
         * Map custom classes to rows from row object data.
         * Define this property in rgRow object and this will be mapped as rgRow class.
         */
        this.rowClass = '';
        /**
         * Autosize config.
         * Enables columns autoSize.
         * For more details check `autoSizeColumn` plugin.
         * By default disabled, hence operation is not performance efficient.
         * `true` to enable with default params (double header separator click for autosize).
         * Or define config. See `AutoSizeColumnConfig` for more details.
         */
        this.autoSizeColumn = false;
        /**
         * Enables filter plugin.
         * Can be boolean.
         * Or can be filter collection See `FilterCollection` for more info.
         */
        this.filter = false;
        /**
         * Enable column move plugin.
         */
        this.canMoveColumns = false;
        /**
         * Trimmed rows.
         * Functionality which allows to hide rows from main data set.
         * `trimmedRows` are physical `rgRow` indexes to hide.
         */
        this.trimmedRows = {};
        /**
         * Enable export plugin.
         */
        this.exporting = false;
        /**
         * Stretch strategy for columns by `StretchColumn` plugin.
         * For example if there are more space on the right last column size would be increased.
         */
        this.stretch = false;
        /**
         * Additional data to be passed to plugins, renders or editors.
         * For example if you need to pass Vue component instance.
         */
        this.additionalData = {};
        /**
         * Disable lazy rendering mode for the `X axis`.
         * Use when not many columns present and you don't need rerenader cells during scroll.
         * Can be used for initial rendering performance improvement.
         */
        this.disableVirtualX = false;
        /**
         * Disable lazy rendering mode for the `Y axis`.
         * Use when not many rows present and you don't need rerenader cells during scroll.
         * Can be used for initial rendering performance improvement.
         */
        this.disableVirtualY = false;
        /**
         * Please only hide the attribution if you are subscribed to Pro version
         */
        this.hideAttribution = false;
        /**
         * Prevent rendering until job is done.
         * Can be used for initial rendering performance improvement.
         * When several plugins require initial rendering this will prevent double initial rendering.
         */
        this.jobsBeforeRender = [];
        /**
         * Register new virtual node inside of grid.
         * Used for additional items creation such as plugin elements.
         * Should be set before grid render inside of plugins.
         * Can return VNode result of h() function or a function that returns VNode.
         * Function can be used for performance improvement and additional renders.
         */
        this.registerVNode = [];
        /**
         * Enable accessibility. If disabled, the grid will not be accessible.
         * @default true
         */
        this.accessible = true;
        /**
         * Enable right-to-left (RTL) mode. When enabled, columns will be displayed from right to left.
         * @default false
         */
        this.rtl = false;
        /**
         * Disable native drag&drop plugin.
         */
        this.canDrag = true;
        this.extraElements = [];
        this.pluginService = new PluginService();
        this.viewport = null;
        this.isInited = false;
    }
    // #endregion
    // #region Methods
    /**
     * Refreshes data viewport.
     * Can be specific part as rgRow or pinned rgRow or 'all' by default.
     */
    async refresh(type = 'all') {
        if (!this.dataProvider) {
            throw new Error('Not connected');
        }
        this.dataProvider.refresh(type);
    }
    /**
     * Refreshes data at specified cell.
     * Useful for performance optimization.
     * No viewport update will be triggered.
     *
     * @example
     * const grid = document.querySelector('revo-grid');
     * grid.setDataAt({ row: 0, col: 0, val: 'test' }); // refresh
     */
    async setDataAt({ row, col, colType = 'rgCol', rowType = 'rgRow', val, skipDataUpdate = false }) {
        var _a;
        if (this.dataProvider && this.columnProvider && !skipDataUpdate) {
            const columnProp = (_a = this.columnProvider.getColumn(col, colType)) === null || _a === void 0 ? void 0 : _a.prop;
            if (typeof columnProp !== 'undefined') {
                this.dataProvider.setCellData({
                    type: rowType,
                    rowIndex: row,
                    prop: columnProp,
                    val,
                }, false);
            }
        }
        const dataElement = this.element.querySelector(`revogr-data[type="${rowType}"][col-type="${colType}"]`);
        return dataElement === null || dataElement === void 0 ? void 0 : dataElement.updateCell({
            row,
            col,
        });
    }
    /**
     * Scrolls viewport to specified row by index.
     */
    async scrollToRow(coordinate = 0) {
        if (!this.dimensionProvider) {
            throw new Error('Not connected');
        }
        const y = this.dimensionProvider.getViewPortPos({
            coordinate,
            dimension: 'rgRow',
        });
        await this.scrollToCoordinate({ y });
    }
    /**
     * Scrolls viewport to specified column by index.
     */
    async scrollToColumnIndex(coordinate = 0) {
        if (!this.dimensionProvider) {
            throw new Error('Not connected');
        }
        const x = this.dimensionProvider.getViewPortPos({
            coordinate,
            dimension: 'rgCol',
        });
        await this.scrollToCoordinate({ x });
    }
    /**
     * Scrolls viewport to specified column by prop
     */
    async scrollToColumnProp(prop, dimension = 'rgCol') {
        if (!this.dimensionProvider || !this.columnProvider) {
            throw new Error('Not connected');
        }
        const coordinate = this.columnProvider.getColumnIndexByProp(prop, dimension);
        if (coordinate < 0) {
            // already on the screen
            return;
        }
        const x = this.dimensionProvider.getViewPortPos({
            coordinate,
            dimension,
        });
        await this.scrollToCoordinate({ x });
    }
    /** Update columns */
    async updateColumns(cols) {
        var _a;
        (_a = this.columnProvider) === null || _a === void 0 ? void 0 : _a.updateColumns(cols);
    }
    /** Add trimmed by type */
    async addTrimmed(trimmed, trimmedType = 'external', type = 'rgRow') {
        if (!this.dataProvider) {
            throw new Error('Not connected');
        }
        const event = this.beforetrimmed.emit({
            trimmed,
            trimmedType,
            type,
        });
        if (event.defaultPrevented) {
            return event;
        }
        this.dataProvider.setTrimmed({ [trimmedType]: event.detail.trimmed }, type);
        this.aftertrimmed.emit();
        return event;
    }
    /**  Scrolls view port to coordinate */
    async scrollToCoordinate(cell) {
        var _a;
        (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.scrollToCell(cell);
    }
    /**  Open editor for cell. */
    async setCellEdit(rgRow, prop, rowSource = 'rgRow') {
        var _a;
        const rgCol = getColumnByProp(this.columns, prop);
        if (!rgCol) {
            return;
        }
        await timeout();
        const colGroup = rgCol.pin || 'rgCol';
        if (!this.columnProvider) {
            throw new Error('Not connected');
        }
        (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.setEdit(rgRow, this.columnProvider.getColumnIndexByProp(prop, colGroup), colGroup, rowSource);
    }
    /**  Set focus range. */
    async setCellsFocus(cellStart = { x: 0, y: 0 }, cellEnd = { x: 0, y: 0 }, colType = 'rgCol', rowType = 'rgRow') {
        var _a;
        (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.setFocus(colType, rowType, cellStart, cellEnd);
    }
    /**  Get data from source */
    async getSource(type = 'rgRow') {
        if (!this.dataProvider) {
            throw new Error('Not connected');
        }
        return this.dataProvider.stores[type].store.get('source');
    }
    /**
     * Get data from visible part of source
     * Trimmed/filtered rows will be excluded
     * @param type - type of source
     */
    async getVisibleSource(type = 'rgRow') {
        if (!this.dataProvider) {
            throw new Error('Not connected');
        }
        return getVisibleSourceItem(this.dataProvider.stores[type].store);
    }
    /**
     * Provides access to rows internal store observer
     * Can be used for plugin support
     * @param type - type of source
     */
    async getSourceStore(type = 'rgRow') {
        if (!this.dataProvider) {
            throw new Error('Not connected');
        }
        return this.dataProvider.stores[type].store;
    }
    /**
     * Provides access to column internal store observer
     * Can be used for plugin support
     * @param type - type of column
     */
    async getColumnStore(type = 'rgCol') {
        if (!this.columnProvider) {
            throw new Error('Not connected');
        }
        return this.columnProvider.stores[type].store;
    }
    /**
     * Update column sorting
     * @param column - column prop and cellCompare
     * @param order - order to apply
     * @param additive - if false will replace current order
     *
     * later passed to SortingPlugin
     */
    async updateColumnSorting(column, order, additive) {
        this.sortingconfigchanged.emit({
            columns: [{
                    prop: column.prop,
                    order,
                    cellCompare: column.cellCompare,
                }],
            additive,
        });
    }
    /**
     * Clears column sorting
     */
    async clearSorting() {
        this.sortingconfigchanged.emit({
            columns: [],
        });
    }
    /**
     * Receive all columns in data source
     */
    async getColumns() {
        if (!this.columnProvider) {
            throw new Error('Not connected');
        }
        return this.columnProvider.getColumns();
    }
    /**
     * Clear current grid focus. Grid has no longer focus on it.
     */
    async clearFocus() {
        var _a, _b;
        const focused = (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.getFocused();
        const event = this.beforefocuslost.emit(focused);
        if (event.defaultPrevented) {
            return;
        }
        (_b = this.selectionStoreConnector) === null || _b === void 0 ? void 0 : _b.clearAll();
    }
    /**
     * Get all active plugins instances
     */
    async getPlugins() {
        return this.pluginService.get();
    }
    /**
     * Get the currently focused cell.
     */
    async getFocused() {
        var _a, _b;
        return (_b = (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.getFocused()) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * Get size of content
     * Including all pinned data
     */
    async getContentSize() {
        var _a;
        if (!this.dimensionProvider) {
            throw new Error('Not connected');
        }
        return (_a = this.dimensionProvider) === null || _a === void 0 ? void 0 : _a.getFullSize();
    }
    /**
     * Get the currently selected Range.
     */
    async getSelectedRange() {
        var _a, _b;
        return (_b = (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.getSelectedRange()) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * Refresh extra elements. Triggers re-rendering of extra elements and functions.
     * Part of extraElements and registerVNode methods.
     * Useful for plugins.
     */
    async refreshExtraElements() {
        var _a;
        (_a = this.extraService) === null || _a === void 0 ? void 0 : _a.refresh();
    }
    /**
     * Get all providers for grid
     * Useful for external grid integration
     */
    async getProviders() {
        return this.getPluginData();
    }
    mousedownHandle(event) {
        const screenX = getPropertyFromEvent(event, 'screenX');
        const screenY = getPropertyFromEvent(event, 'screenY');
        if (screenX === null || screenY === null) {
            return;
        }
        this.clickTrackForFocusClear = screenX + screenY;
    }
    /**
     * To keep your elements from losing focus use mouseup/touchend e.preventDefault();
     */
    async mouseupHandle(event) {
        var _a;
        const screenX = getPropertyFromEvent(event, 'screenX');
        const screenY = getPropertyFromEvent(event, 'screenY');
        if (screenX === null || screenY === null) {
            return;
        }
        if (event.defaultPrevented) {
            return;
        }
        const pos = screenX + screenY;
        // detect if mousemove then do nothing
        if (Math.abs(((_a = this.clickTrackForFocusClear) !== null && _a !== void 0 ? _a : 0) - pos) > 10) {
            return;
        }
        // Check if action finished inside the document
        // if event prevented, or it is current table don't clear focus
        const path = event.composedPath();
        if (!path.includes(this.element) &&
            !(this.element.shadowRoot && path.includes(this.element.shadowRoot))) {
            // Perform actions if the click is outside the component
            await this.clearFocus();
        }
    }
    // #endregion
    // #region Listeners
    /** Drag events */
    onRowDragStarted(e) {
        var _a;
        const dragStart = this.rowdragstart.emit(e.detail);
        if (dragStart.defaultPrevented) {
            e.preventDefault();
            return;
        }
        (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.start(this.element, Object.assign(Object.assign({}, e.detail), dragStart.detail));
    }
    onRowDragEnd() {
        var _a;
        (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.end();
    }
    onRowOrderChange(e) {
        var _a;
        (_a = this.dataProvider) === null || _a === void 0 ? void 0 : _a.changeOrder(e.detail);
    }
    onRowDrag({ detail }) {
        var _a;
        (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.move(detail);
    }
    onRowMouseMove(e) {
        var _a;
        (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.moveTip(e.detail);
    }
    async onCellEdit(e) {
        var _a;
        const { defaultPrevented, detail } = this.beforeedit.emit(e.detail);
        await timeout();
        // apply data
        if (!defaultPrevented) {
            (_a = this.dataProvider) === null || _a === void 0 ? void 0 : _a.setCellData(detail);
            // @feature: incrimental update for cells
            // this.dataProvider.setCellData(detail, false);
            // await this.setDataAt({
            //   row: detail.rowIndex,
            //   col: detail.colIndex,
            //   rowType: detail.type,
            //   colType: detail.colType,
            // });
            this.afteredit.emit(detail);
        }
    }
    onRangeEdit(e) {
        if (!this.dataProvider) {
            throw new Error('Not connected');
        }
        const { defaultPrevented, detail } = this.beforerangeedit.emit(e.detail);
        if (defaultPrevented) {
            e.preventDefault();
            return;
        }
        this.dataProvider.setRangeData(detail.data, detail.type);
        this.afteredit.emit(detail);
    }
    onRangeChanged(e) {
        const beforeange = this.beforerange.emit(e.detail);
        if (beforeange.defaultPrevented) {
            e.preventDefault();
        }
        const beforeFill = this.beforeautofill.emit(beforeange.detail);
        if (beforeFill.defaultPrevented) {
            e.preventDefault();
        }
    }
    onRowDropped(e) {
        // e.cancelBubble = true;
        const { defaultPrevented } = this.roworderchanged.emit(e.detail);
        if (defaultPrevented) {
            e.preventDefault();
        }
    }
    onHeaderClick(e) {
        const { defaultPrevented } = this.headerclick.emit(Object.assign(Object.assign({}, e.detail.column), { originalEvent: e.detail.originalEvent }));
        if (defaultPrevented) {
            e.preventDefault();
        }
    }
    onCellFocus(e) {
        const { defaultPrevented } = this.beforecellfocus.emit(e.detail);
        if (!this.canFocus || defaultPrevented) {
            e.preventDefault();
        }
    }
    // #endregion
    // #region Watchers
    columnTypesChanged() {
        // Column format change will trigger column structure update
        this.columnChanged(this.columns);
    }
    columnChanged(newVal = [], _prevVal = undefined, __watchName = 'columns', init = false) {
        if (!this.dimensionProvider || !this.columnProvider) {
            return;
        }
        const columnGather = getColumns(newVal, 0, this.columnTypes);
        const beforeSetEvent = this.beforecolumnsset.emit(columnGather);
        if (beforeSetEvent.defaultPrevented) {
            return;
        }
        this.dimensionProvider.applyNewColumns(beforeSetEvent.detail.columns, this.disableVirtualX, init);
        const beforeApplyEvent = this.beforecolumnapplied.emit(columnGather);
        if (beforeApplyEvent.defaultPrevented) {
            return;
        }
        const columns = this.columnProvider.setColumns(beforeApplyEvent.detail);
        this.aftercolumnsset.emit({
            columns,
            order: Object.entries(beforeApplyEvent.detail.sort).reduce((acc, [prop, column]) => {
                acc[prop] = column.order;
                return acc;
            }, {}),
        });
    }
    disableVirtualXChanged(newVal = false, prevVal = false) {
        if (newVal === prevVal) {
            return;
        }
        this.columnChanged(this.columns);
    }
    rowSizeChanged(s) {
        if (!this.dimensionProvider) {
            return;
        }
        // clear existing data
        this.dimensionProvider.setSettings({ originItemSize: s }, 'rgRow');
        this.rowDefChanged(this.rowDefinitions, this.rowDefinitions, 'rowSize', true);
    }
    themeChanged(t, _, __ = 'theme', init = false) {
        if (!this.dimensionProvider) {
            return;
        }
        this.themeService.register(t);
        this.dimensionProvider.setSettings({ originItemSize: this.themeService.rowSize }, 'rgRow');
        this.dimensionProvider.setSettings({ originItemSize: this.colSize }, 'rgCol');
        // if theme change we need to reapply row size and reset viewport
        if (!init) {
            // clear existing data
            this.dimensionProvider.setSettings({ originItemSize: this.themeService.rowSize }, 'rgRow');
            this.rowDefChanged(
            // for cases when some custom size present and not
            this.rowDefinitions, this.rowDefinitions, 'theme', true);
        }
        this.afterthemechanged.emit(t);
    }
    dataSourceChanged(newVal = [], _, watchName) {
        if (!this.dataProvider) {
            return;
        }
        let type = 'rgRow';
        switch (watchName) {
            case 'pinnedBottomSource':
                type = 'rowPinEnd';
                break;
            case 'pinnedTopSource':
                type = 'rowPinStart';
                break;
            case 'source':
                type = 'rgRow';
                /**
                 * Applied for source only for cross compatability between plugins
                 */
                const beforesourceset = this.beforesourceset.emit({
                    type,
                    source: newVal,
                });
                newVal = beforesourceset.detail.source;
                break;
        }
        const beforesourceset = this.beforeanysource.emit({
            type,
            source: newVal,
        });
        const newSource = [...beforesourceset.detail.source];
        this.dataProvider.setData(newSource, type, this.disableVirtualY);
        /**
         * Applied for source only for cross compatability between plugins
         */
        if (watchName === 'source') {
            this.aftersourceset.emit({
                type,
                source: newVal,
            });
        }
        this.afteranysource.emit({
            type,
            source: newVal,
        });
    }
    disableVirtualYChanged(newVal = false, prevVal = false) {
        if (newVal === prevVal) {
            return;
        }
        this.dataSourceChanged(this.source, this.source, 'source');
    }
    rowDefChanged(after, before, _watchName, forceUpdate = true) {
        // in firefox it's triggered before init
        if (!this.dimensionProvider || !this.dataProvider) {
            return;
        }
        const { detail: { vals: newVal, oldVals: oldVal }, } = this.beforerowdefinition.emit({
            vals: after,
            oldVals: before,
        });
        // apply new values
        const newRows = rowDefinitionByType(newVal);
        // clear current defs
        if (oldVal) {
            const remove = rowDefinitionRemoveByType(oldVal);
            // clear all old data and drop sizes
            for (const t in remove) {
                if (remove.hasOwnProperty(t)) {
                    const type = t;
                    const store = this.dataProvider.stores[type];
                    const sourceLength = store.store.get('source').length;
                    this.dimensionProvider.clearSize(type, sourceLength);
                }
            }
        }
        // set new sizes
        rowTypes.forEach((t) => {
            var _a;
            const newSizes = newRows[t];
            // apply new sizes or force update
            if (newSizes || forceUpdate) {
                (_a = this.dimensionProvider) === null || _a === void 0 ? void 0 : _a.setCustomSizes(t, (newSizes === null || newSizes === void 0 ? void 0 : newSizes.sizes) || {});
            }
        });
    }
    trimmedRowsChanged(newVal = {}) {
        this.addTrimmed(newVal);
    }
    /**
     * Grouping
     */
    groupingChanged(newVal = {}) {
        var _a;
        (_a = this.pluginService.getByClass(GroupingRowPlugin)) === null || _a === void 0 ? void 0 : _a.setGrouping(newVal || {});
    }
    /**
     * Stretch Plugin Apply
     */
    applyStretch(isStretch) {
        if (!this.dimensionProvider || !this.dataProvider || !this.columnProvider || !this.viewportProvider) {
            return;
        }
        if (isStretch === 'false') {
            isStretch = false;
        }
        const pluginData = this.getPluginData();
        if (!pluginData) {
            return;
        }
        const stretch = this.pluginService.getByClass(StretchColumn);
        if ((typeof isStretch === 'boolean' && isStretch) || isStretch === 'true') {
            if (!stretch) {
                this.pluginService.add(new StretchColumn(this.element, pluginData));
            }
            else if (isStretchPlugin(stretch)) {
                stretch.applyStretch(this.columnProvider.getRawColumns());
            }
        }
        else if (stretch) {
            this.pluginService.remove(stretch);
        }
    }
    applyFilter(cfg) {
        this.filterconfigchanged.emit(cfg);
    }
    applySorting(cfg) {
        this.sortingconfigchanged.emit(cfg);
    }
    rowHeadersChange(rowHeaders) {
        this.rowheaderschanged.emit(rowHeaders);
    }
    /**
     * Register external VNodes
     */
    registerOutsideVNodes(elements = []) {
        this.extraElements = elements;
    }
    additionalDataChanged(data) {
        this.additionaldatachanged.emit(data);
    }
    /**
     * Watch for RTL changes and reapply column ordering
     */
    rtlChanged() {
        // The RTL plugin will handle the transformation automatically
        // Just trigger a column refresh to ensure the plugin processes the change
        this.columnChanged(this.columns);
    }
    /**
     * User can add plugins via plugins property
     */
    pluginsChanged(plugins = [], prevPlugins) {
        this.pluginService.addUserPluginsAndCreate(this.element, plugins, prevPlugins, this.getPluginData());
    }
    // #endregion
    // #region Plugins
    setPlugins() {
        // remove old plugins if any
        this.removePlugins();
        // pass data provider to plugins
        const pluginData = this.getPluginData();
        if (!pluginData) {
            return;
        }
        // register system plugins
        this.setCorePlugins(pluginData);
        // register user plugins
        this.pluginsChanged(this.plugins);
    }
    setCorePlugins(pluginData) {
        if (this.accessible) {
            this.pluginService.add(new WCAGPlugin(this.element, pluginData));
        }
        // register RTL plugin
        this.pluginService.add(new RTLPlugin(this.element, pluginData));
        // register auto size plugin
        if (this.autoSizeColumn) {
            this.pluginService.add(new AutoSizeColumnPlugin(this.element, pluginData, typeof this.autoSizeColumn === 'object'
                ? this.autoSizeColumn
                : undefined));
        }
        // register filter plugin
        if (this.filter) {
            this.pluginService.add(new FilterPlugin(this.element, pluginData, typeof this.filter === 'object' ? this.filter : undefined));
        }
        // register export plugin
        if (this.exporting) {
            this.pluginService.add(new ExportFilePlugin(this.element, pluginData));
        }
        // register sorting plugin
        this.pluginService.add(new SortingPlugin(this.element, pluginData));
        // register grouping plugin
        this.pluginService.add(new GroupingRowPlugin(this.element, pluginData));
        if (this.canMoveColumns) {
            this.pluginService.add(new ColumnMovePlugin(this.element, pluginData));
        }
    }
    getPluginData() {
        if (!this.dimensionProvider || !this.dataProvider || !this.columnProvider || !this.viewportProvider || !this.selectionStoreConnector) {
            return;
        }
        // pass data provider to plugins
        const pluginData = {
            data: this.dataProvider,
            column: this.columnProvider,
            dimension: this.dimensionProvider,
            viewport: this.viewportProvider,
            selection: this.selectionStoreConnector,
            plugins: this.pluginService,
        };
        return pluginData;
    }
    removePlugins() {
        this.pluginService.destroy();
    }
    // #endregion
    // if reconnect to dom we need to set up plugins
    connectedCallback() {
        if (this.isInited) {
            this.setPlugins();
        }
        this.created.emit();
    }
    /**
     * Called once just after the component is first connected to the DOM.
     * Since this method is only called once, it's a good place to load data asynchronously and to setup the state
     * without triggering extra re-renders.
     * A promise can be returned, that can be used to wait for the first render().
     */
    componentWillLoad() {
        var _a;
        // #region Setup Providers
        this.viewportProvider = new ViewportProvider();
        this.themeService = new ThemeService({
            rowSize: this.rowSize,
        });
        this.dimensionProvider = new DimensionProvider(this.viewportProvider, {
            realSizeChanged: (k) => this.contentsizechanged.emit(k),
        });
        this.columnProvider = new ColumnDataProvider();
        this.selectionStoreConnector = new SelectionStoreConnector();
        this.dataProvider = new DataProvider(this.dimensionProvider);
        // #endregion
        this.registerOutsideVNodes(this.registerVNode);
        // init plugins
        this.setPlugins();
        // set data
        this.applyStretch(this.stretch);
        this.themeChanged(this.theme, undefined, undefined, true);
        this.columnChanged(this.columns, undefined, undefined, true);
        this.dataSourceChanged(this.source, undefined, 'source');
        this.dataSourceChanged(this.pinnedTopSource, undefined, 'pinnedTopSource');
        this.dataSourceChanged(this.pinnedBottomSource, undefined, 'pinnedBottomSource');
        if (Object.keys((_a = this.trimmedRows) !== null && _a !== void 0 ? _a : {}).length > 0) {
            this.trimmedRowsChanged(this.trimmedRows);
        }
        this.rowDefChanged(this.rowDefinitions);
        // init grouping
        if (this.grouping && Object.keys(this.grouping).length > 0) {
            this.groupingChanged(this.grouping);
        }
        // init scrolling service
        this.scrollingService = new GridScrollingService((e) => {
            var _a;
            (_a = this.dimensionProvider) === null || _a === void 0 ? void 0 : _a.setViewPortCoordinate({
                coordinate: e.coordinate,
                type: e.dimension,
            });
            this.viewportscroll.emit(e);
        });
        this.aftergridinit.emit();
        // set inited flag for connectedCallback
        this.isInited = true;
    }
    componentWillRender() {
        const event = this.beforegridrender.emit();
        if (event.defaultPrevented) {
            return false;
        }
        return Promise.all(this.jobsBeforeRender);
    }
    componentDidRender() {
        this.aftergridrender.emit();
    }
    render() {
        if (!this.dimensionProvider || !this.dataProvider || !this.columnProvider || !this.viewportProvider || !this.selectionStoreConnector) {
            return;
        }
        const contentHeight = this.dimensionProvider.stores['rgRow'].store.get('realSize');
        // init viewport service helpers
        this.viewport = new ViewportService({
            columnProvider: this.columnProvider,
            dataProvider: this.dataProvider,
            dimensionProvider: this.dimensionProvider,
            viewportProvider: this.viewportProvider,
            scrollingService: this.scrollingService,
            orderService: this.orderService,
            selectionStoreConnector: this.selectionStoreConnector,
            disableVirtualX: this.disableVirtualX,
            disableVirtualY: this.disableVirtualY,
            resize: c => this.aftercolumnresize.emit(c),
        }, contentHeight);
        // #region ViewportSections
        /**
         * The code renders a viewport divided into sections.
         * It starts by rendering the pinned start, data, and pinned end sections.
         * Within each section, it renders columns along with their headers, pinned top, center data, and pinned bottom.
         * The code iterates over the columns and their data to generate the view port's HTML structure.
         */
        const viewportSections = [];
        // Row headers setting
        if (this.rowHeaders && this.viewport.columns.length) {
            const anyView = this.viewport.columns[0];
            viewportSections.push(h("revogr-row-headers", { additionalData: this.additionalData, height: contentHeight, rowClass: this.rowClass, resize: this.resize, dataPorts: anyView.dataPorts, headerProp: anyView.headerProp, jobsBeforeRender: this.jobsBeforeRender, rowHeaderColumn: typeof this.rowHeaders === 'object' ? this.rowHeaders : undefined, onScrollview: ({ detail: e }) => this.scrollingService.proxyScroll(e, 'headerRow'), onRef: ({ detail: e }) => this.scrollingService.registerElement(e, 'headerRow') }));
        }
        // Viewport section render
        const isMobile = isMobileDevice();
        const viewPortHtml = [];
        // Render viewports column(horizontal sections)
        for (let view of this.viewport.columns) {
            const headerProperties = Object.assign(Object.assign({}, view.headerProp), { type: view.type, additionalData: this.additionalData, viewportCol: view.viewportCol, selectionStore: view.columnSelectionStore, canResize: this.resize, readonly: this.readonly, columnFilter: !!this.filter });
            // Column headers
            const dataViews = [
                h("revogr-header", Object.assign({}, headerProperties, { slot: HEADER_SLOT })),
            ];
            // Render viewport data (vertical sections)
            view.dataPorts.forEach(data => {
                const key = `${data.type}_${view.type}`;
                const dataView = (h("revogr-overlay-selection", Object.assign({}, data, { canDrag: this.canDrag && data.canDrag, isMobileDevice: isMobile, onSelectall: () => { var _a; return (_a = this.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.selectAll(); }, editors: this.editors, readonly: this.readonly, range: this.range, useClipboard: this.useClipboard, applyChangesOnClose: this.applyOnClose, additionalData: this.additionalData, slot: data.slot, onBeforenextvpfocus: (e) => { var _a; return (_a = this.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.beforeNextFocusCell(e.detail); }, onCanceledit: () => { var _a; return (_a = this.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.setEdit(false); }, onSetedit: ({ detail }) => {
                        var _a;
                        const event = this.beforeeditstart.emit(detail);
                        if (!event.defaultPrevented) {
                            (_a = this.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.setEdit(detail.val);
                        }
                    } }), h("revogr-data", Object.assign({}, data, { colType: view.type, key: key, readonly: this.readonly, range: this.range, rowClass: this.rowClass, rowSelectionStore: data.rowSelectionStore, additionalData: this.additionalData, jobsBeforeRender: this.jobsBeforeRender, slot: DATA_SLOT }), h("slot", { name: `data-${view.type}-${data.type}` })), h("revogr-temp-range", { selectionStore: data.selectionStore, dimensionRow: data.dimensionRow, dimensionCol: data.dimensionCol }), h("revogr-focus", { colData: data.colData, dataStore: data.dataStore, focusTemplate: this.focusTemplate, rowType: data.type, colType: view.type, selectionStore: data.selectionStore, dimensionRow: data.dimensionRow, dimensionCol: data.dimensionCol }, h("slot", { name: `focus-${view.type}-${data.type}` }))));
                dataViews.push(dataView);
            });
            // Add viewport scroll in the end
            viewPortHtml.push(h("revogr-viewport-scroll", Object.assign({}, view.prop, { ref: el => this.scrollingService.registerElement(el, `${view.prop.key}`), onScrollviewport: e => this.scrollingService.proxyScroll(e.detail, `${view.prop.key}`), onScrollviewportsilent: e => this.scrollingService.scrollSilentService(e.detail, `${view.prop.key}`) }), dataViews));
        }
        viewportSections.push(viewPortHtml);
        // #endregion
        const typeRow = 'rgRow';
        const typeCol = 'rgCol';
        const viewports = this.viewportProvider.stores;
        const dimensions = this.dimensionProvider.stores;
        const verticalScroll = (h("revogr-scroll-virtual", { class: "vertical", dimension: typeRow, clientSize: viewports[typeRow].store.get('clientSize'), virtualSize: viewports[typeRow].store.get('virtualSize'), realSize: dimensions[typeRow].store.get('realSize'), ref: el => this.scrollingService.registerElement(el, 'rowScroll'), onScrollvirtual: e => this.scrollingService.proxyScroll(e.detail) }));
        const horizontalScroll = (h("revogr-scroll-virtual", { class: "horizontal", dimension: typeCol, clientSize: viewports[typeCol].store.get('clientSize'), virtualSize: viewports[typeCol].store.get('virtualSize'), realSize: dimensions[typeCol].store.get('realSize'), ref: el => this.scrollingService.registerElement(el, 'colScroll'), onScrollvirtual: e => this.scrollingService.proxyScroll(e.detail) }));
        return (h(Host, { dir: this.rtl ? 'rtl' : 'ltr' }, this.hideAttribution ? null : (h("revogr-attribution", { class: "attribution" })), h("slot", { name: "header" }), h("div", { class: "main-viewport", onClick: (e) => {
                var _a;
                if (e.currentTarget === e.target) {
                    (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.clearEdit();
                }
            } }, h("div", { class: "viewports" }, h("slot", { name: "viewport" }), viewportSections, verticalScroll, h(OrderRenderer, { ref: e => (this.orderService = e) }))), horizontalScroll, h("revogr-extra", { ref: el => (this.extraService = el), nodes: this.extraElements }), h("slot", { name: "footer" })));
    }
    disconnectedCallback() {
        // Remove all plugins, to avoid memory leaks
        // and unexpected behaviour when the component is removed
        this.removePlugins();
    }
    static get is() { return "revo-grid"; }
    static get originalStyleUrls() {
        return {
            "$": ["revo-grid-style.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["revo-grid-style.css"]
        };
    }
    static get properties() {
        return {
            "rowHeaders": {
                "type": "boolean",
                "attribute": "row-headers",
                "mutable": false,
                "complexType": {
                    "original": "RowHeaders | boolean",
                    "resolved": "RowHeaders | boolean",
                    "references": {
                        "RowHeaders": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::RowHeaders"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Excel like functionality.\nShow row numbers.\nAlso can be used for custom row header render if object provided."
                },
                "getter": false,
                "setter": false,
                "reflect": false
            },
            "frameSize": {
                "type": "number",
                "attribute": "frame-size",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Defines how many rows/columns should be rendered outside visible area."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "1"
            },
            "rowSize": {
                "type": "number",
                "attribute": "row-size",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Indicates default rgRow size.\nBy default 0, means theme package size will be applied\n\nAlternatively you can use `rowSize` to reset viewport"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "0"
            },
            "colSize": {
                "type": "number",
                "attribute": "col-size",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Indicates default column size."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "100"
            },
            "range": {
                "type": "boolean",
                "attribute": "range",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When true, user can range selection."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "readonly": {
                "type": "boolean",
                "attribute": "readonly",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When true, grid in read only mode."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "resize": {
                "type": "boolean",
                "attribute": "resize",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When true, columns are resizable."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "canFocus": {
                "type": "boolean",
                "attribute": "can-focus",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When true cell focus appear."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "true"
            },
            "useClipboard": {
                "type": "boolean",
                "attribute": "use-clipboard",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When true enable clipboard."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "true"
            },
            "columns": {
                "type": "unknown",
                "attribute": "columns",
                "mutable": false,
                "complexType": {
                    "original": "(ColumnRegular | ColumnGrouping)[]",
                    "resolved": "(ColumnRegular | ColumnGrouping<any>)[]",
                    "references": {
                        "ColumnRegular": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnRegular"
                        },
                        "ColumnGrouping": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnGrouping"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Columns - defines an array of grid columns.\nCan be column or grouped column."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "[]"
            },
            "source": {
                "type": "unknown",
                "attribute": "source",
                "mutable": false,
                "complexType": {
                    "original": "DataType[]",
                    "resolved": "DataType[]",
                    "references": {
                        "DataType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DataType"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Source - defines main data source.\nCan be an Object or 2 dimensional array([][]);\nKeys/indexes referenced from columns Prop."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "[]"
            },
            "pinnedTopSource": {
                "type": "unknown",
                "attribute": "pinned-top-source",
                "mutable": false,
                "complexType": {
                    "original": "DataType[]",
                    "resolved": "DataType[]",
                    "references": {
                        "DataType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DataType"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Pinned top Source: {[T in ColumnProp]: any} - defines pinned top rows data source."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "[]"
            },
            "pinnedBottomSource": {
                "type": "unknown",
                "attribute": "pinned-bottom-source",
                "mutable": false,
                "complexType": {
                    "original": "DataType[]",
                    "resolved": "DataType[]",
                    "references": {
                        "DataType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DataType"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Pinned bottom Source: {[T in ColumnProp]: any} - defines pinned bottom rows data source."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "[]"
            },
            "rowDefinitions": {
                "type": "unknown",
                "attribute": "row-definitions",
                "mutable": false,
                "complexType": {
                    "original": "RowDefinition[]",
                    "resolved": "RowDefinition[]",
                    "references": {
                        "RowDefinition": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::RowDefinition"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Custom row properies to be applied. See `RowDefinition` for more info."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "[]"
            },
            "editors": {
                "type": "unknown",
                "attribute": "editors",
                "mutable": false,
                "complexType": {
                    "original": "Editors",
                    "resolved": "{ [name: string]: EditorCtr; }",
                    "references": {
                        "Editors": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::Editors"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Custom editors register."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "{}"
            },
            "applyOnClose": {
                "type": "boolean",
                "attribute": "apply-on-close",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Apply changes in editor when closed except 'Escape' cases.\nIf custom editor in use method getValue required.\nCheck interfaces.d.ts `EditorBase` for more info."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "plugins": {
                "type": "unknown",
                "attribute": "plugins",
                "mutable": false,
                "complexType": {
                    "original": "GridPlugin[]",
                    "resolved": "(typeof BasePlugin)[]",
                    "references": {
                        "GridPlugin": {
                            "location": "import",
                            "path": "../../plugins/base.plugin",
                            "id": "src/plugins/base.plugin.ts::GridPlugin"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Custom grid plugins. Can be added or removed at runtime.\nEvery plugin should be inherited from BasePlugin class.\n\nFor more details check [Plugin guide](https://rv-grid.com/guide/plugin/)"
                },
                "getter": false,
                "setter": false,
                "defaultValue": "[]"
            },
            "columnTypes": {
                "type": "unknown",
                "attribute": "column-types",
                "mutable": false,
                "complexType": {
                    "original": "{ [name: string]: ColumnType }",
                    "resolved": "{ [name: string]: ColumnType; }",
                    "references": {
                        "ColumnType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnType"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Column Types Format.\nEvery type represent multiple column properties.\nTypes will be merged but can be replaced with column properties.\nTypes were made as separate objects to be reusable per multiple columns."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "{}"
            },
            "theme": {
                "type": "string",
                "attribute": "theme",
                "mutable": true,
                "complexType": {
                    "original": "Theme",
                    "resolved": "string",
                    "references": {
                        "Theme": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::Theme"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Theme name."
                },
                "getter": false,
                "setter": false,
                "reflect": true,
                "defaultValue": "'default'"
            },
            "rowClass": {
                "type": "string",
                "attribute": "row-class",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Row class property mapping.\nMap custom classes to rows from row object data.\nDefine this property in rgRow object and this will be mapped as rgRow class."
                },
                "getter": false,
                "setter": false,
                "reflect": true,
                "defaultValue": "''"
            },
            "autoSizeColumn": {
                "type": "boolean",
                "attribute": "auto-size-column",
                "mutable": false,
                "complexType": {
                    "original": "boolean | AutoSizeColumnConfig",
                    "resolved": "boolean | { mode?: ColumnAutoSizeMode | undefined; allColumns?: boolean | undefined; letterBlockSize?: number | undefined; preciseSize?: boolean | undefined; }",
                    "references": {
                        "AutoSizeColumnConfig": {
                            "location": "import",
                            "path": "../../plugins/column.auto-size.plugin",
                            "id": "src/plugins/column.auto-size.plugin.ts::AutoSizeColumnConfig"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Autosize config.\nEnables columns autoSize.\nFor more details check `autoSizeColumn` plugin.\nBy default disabled, hence operation is not performance efficient.\n`true` to enable with default params (double header separator click for autosize).\nOr define config. See `AutoSizeColumnConfig` for more details."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "filter": {
                "type": "boolean",
                "attribute": "filter",
                "mutable": false,
                "complexType": {
                    "original": "boolean | ColumnFilterConfig",
                    "resolved": "ColumnFilterConfig | boolean",
                    "references": {
                        "ColumnFilterConfig": {
                            "location": "import",
                            "path": "../../plugins/filter/filter.types",
                            "id": "src/plugins/filter/filter.types.ts::ColumnFilterConfig"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Enables filter plugin.\nCan be boolean.\nOr can be filter collection See `FilterCollection` for more info."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "sorting": {
                "type": "unknown",
                "attribute": "sorting",
                "mutable": false,
                "complexType": {
                    "original": "SortingConfig",
                    "resolved": "undefined | { columns?: { prop: ColumnProp; order: Order; cellCompare?: CellCompareFunc | undefined; }[] | undefined; additive?: boolean | undefined; }",
                    "references": {
                        "SortingConfig": {
                            "location": "import",
                            "path": "../../plugins",
                            "id": "src/plugins/index.ts::SortingConfig"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Alternative way to set sorting.\n`{columns: [{prop: 'name', order: 'asc'}]}`\nUse SortingPlugin to get current sorting state"
                },
                "getter": false,
                "setter": false
            },
            "focusTemplate": {
                "type": "unknown",
                "attribute": "focus-template",
                "mutable": false,
                "complexType": {
                    "original": "FocusTemplateFunc",
                    "resolved": "(createElement: HyperFunc<VNode>, detail: FocusRenderEvent) => any",
                    "references": {
                        "FocusTemplateFunc": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::FocusTemplateFunc"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Apply changes typed in editor on editor close except Escape cases.\nIf custom editor in use method `getValue` required.\nCheck `interfaces.d.ts` `EditorBase` for more info."
                },
                "getter": false,
                "setter": false
            },
            "canMoveColumns": {
                "type": "boolean",
                "attribute": "can-move-columns",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Enable column move plugin."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "trimmedRows": {
                "type": "unknown",
                "attribute": "trimmed-rows",
                "mutable": false,
                "complexType": {
                    "original": "Record<number, boolean>",
                    "resolved": "{ [x: number]: boolean; }",
                    "references": {
                        "Record": {
                            "location": "global",
                            "id": "global::Record"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Trimmed rows.\nFunctionality which allows to hide rows from main data set.\n`trimmedRows` are physical `rgRow` indexes to hide."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "{}"
            },
            "exporting": {
                "type": "boolean",
                "attribute": "exporting",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Enable export plugin."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "grouping": {
                "type": "unknown",
                "attribute": "grouping",
                "mutable": false,
                "complexType": {
                    "original": "GroupingOptions",
                    "resolved": "{ props?: ColumnProp[] | undefined; preserveGroupingOnUpdate?: boolean | undefined; groupLabelTemplate?: GroupLabelTemplateFunc | undefined; } & ExpandedOptions",
                    "references": {
                        "GroupingOptions": {
                            "location": "import",
                            "path": "../../plugins/groupingRow/grouping.row.types",
                            "id": "src/plugins/groupingRow/grouping.row.types.ts::GroupingOptions"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Group rows based on this property.\nDefine properties to be groped by grouping plugin See `GroupingOptions`."
                },
                "getter": false,
                "setter": false
            },
            "stretch": {
                "type": "any",
                "attribute": "stretch",
                "mutable": false,
                "complexType": {
                    "original": "boolean | string",
                    "resolved": "boolean | string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Stretch strategy for columns by `StretchColumn` plugin.\nFor example if there are more space on the right last column size would be increased."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "additionalData": {
                "type": "unknown",
                "attribute": "additional-data",
                "mutable": false,
                "complexType": {
                    "original": "AdditionalData",
                    "resolved": "AdditionalData",
                    "references": {
                        "AdditionalData": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::AdditionalData"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Additional data to be passed to plugins, renders or editors.\nFor example if you need to pass Vue component instance."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "{}"
            },
            "disableVirtualX": {
                "type": "boolean",
                "attribute": "disable-virtual-x",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Disable lazy rendering mode for the `X axis`.\nUse when not many columns present and you don't need rerenader cells during scroll.\nCan be used for initial rendering performance improvement."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "disableVirtualY": {
                "type": "boolean",
                "attribute": "disable-virtual-y",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Disable lazy rendering mode for the `Y axis`.\nUse when not many rows present and you don't need rerenader cells during scroll.\nCan be used for initial rendering performance improvement."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "hideAttribution": {
                "type": "boolean",
                "attribute": "hide-attribution",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Please only hide the attribution if you are subscribed to Pro version"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "jobsBeforeRender": {
                "type": "unknown",
                "attribute": "jobs-before-render",
                "mutable": false,
                "complexType": {
                    "original": "Promise<any>[]",
                    "resolved": "Promise<any>[]",
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Prevent rendering until job is done.\nCan be used for initial rendering performance improvement.\nWhen several plugins require initial rendering this will prevent double initial rendering."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "[]"
            },
            "registerVNode": {
                "type": "unknown",
                "attribute": "register-v-node",
                "mutable": false,
                "complexType": {
                    "original": "(\n    | VNode\n    | ((c: ExtraNodeFuncConfig) => VNode)\n  )[]",
                    "resolved": "(VNode | ((c: ExtraNodeFuncConfig) => VNode))[]",
                    "references": {
                        "VNode": {
                            "location": "import",
                            "path": "@stencil/core",
                            "id": "node_modules::VNode"
                        },
                        "ExtraNodeFuncConfig": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ExtraNodeFuncConfig"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Register new virtual node inside of grid.\nUsed for additional items creation such as plugin elements.\nShould be set before grid render inside of plugins.\nCan return VNode result of h() function or a function that returns VNode.\nFunction can be used for performance improvement and additional renders."
                },
                "getter": false,
                "setter": false,
                "defaultValue": "[]"
            },
            "accessible": {
                "type": "boolean",
                "attribute": "accessible",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "default",
                            "text": "true"
                        }],
                    "text": "Enable accessibility. If disabled, the grid will not be accessible."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "true"
            },
            "rtl": {
                "type": "boolean",
                "attribute": "rtl",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "default",
                            "text": "false"
                        }],
                    "text": "Enable right-to-left (RTL) mode. When enabled, columns will be displayed from right to left."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "canDrag": {
                "type": "boolean",
                "attribute": "can-drag",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Disable native drag&drop plugin."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "true"
            }
        };
    }
    static get events() {
        return [{
                "method": "contentsizechanged",
                "name": "contentsizechanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "New content size has been applied. The size excludes the header.\nCurrently, the event responsible for applying the new content size does not provide the actual size.\nTo retrieve the actual content size, you can utilize the `getContentSize` function after the event has been triggered."
                },
                "complexType": {
                    "original": "MultiDimensionType",
                    "resolved": "\"colPinEnd\" | \"colPinStart\" | \"rgCol\" | \"rgRow\" | \"rowPinEnd\" | \"rowPinStart\"",
                    "references": {
                        "MultiDimensionType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::MultiDimensionType"
                        }
                    }
                }
            }, {
                "method": "beforeedit",
                "name": "beforeedit",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Before the data is edited.\nTo prevent the default behavior of editing data and use your own implementation, call `e.preventDefault()`.\nTo override the edit result with your own value, set the `e.val` property to your desired value."
                },
                "complexType": {
                    "original": "BeforeSaveDataDetails",
                    "resolved": "BeforeSaveDataDetails",
                    "references": {
                        "BeforeSaveDataDetails": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::BeforeSaveDataDetails"
                        }
                    }
                }
            }, {
                "method": "beforerangeedit",
                "name": "beforerangeedit",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Before applying range data, specifically when a range selection occurs.\nTo customize the data and prevent the default edit data from being set, you can call `e.preventDefault()`."
                },
                "complexType": {
                    "original": "BeforeRangeSaveDataDetails",
                    "resolved": "{ data: DataLookup; models: Partial<DataLookup>; type: DimensionRows; newRange: RangeArea | null; oldRange: RangeArea | null; }",
                    "references": {
                        "BeforeRangeSaveDataDetails": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::BeforeRangeSaveDataDetails"
                        }
                    }
                }
            }, {
                "method": "afteredit",
                "name": "afteredit",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "After data applied or range changed."
                },
                "complexType": {
                    "original": "AfterEditEvent",
                    "resolved": "BeforeSaveDataDetails | { data: DataLookup; models: Partial<DataLookup>; type: DimensionRows; newRange: RangeArea | null; oldRange: RangeArea | null; }",
                    "references": {
                        "AfterEditEvent": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::AfterEditEvent"
                        }
                    }
                }
            }, {
                "method": "beforeautofill",
                "name": "beforeautofill",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Before autofill is applied.\nTo prevent the default behavior of applying the edit data, you can call `e.preventDefault()`."
                },
                "complexType": {
                    "original": "ChangedRange",
                    "resolved": "{ type: DimensionRows; colType: DimensionCols; newRange: RangeArea; oldRange: RangeArea; mapping: OldNewRangeMapping; newData: { [newRowIndex: number]: DataType; }; }",
                    "references": {
                        "ChangedRange": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ChangedRange"
                        }
                    }
                }
            }, {
                "method": "beforerange",
                "name": "beforerange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Before autofill is applied. Runs before beforeautofill event.\nUse e.preventDefault() to prevent range."
                },
                "complexType": {
                    "original": "ChangedRange",
                    "resolved": "{ type: DimensionRows; colType: DimensionCols; newRange: RangeArea; oldRange: RangeArea; mapping: OldNewRangeMapping; newData: { [newRowIndex: number]: DataType; }; }",
                    "references": {
                        "ChangedRange": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ChangedRange"
                        }
                    }
                }
            }, {
                "method": "afterfocus",
                "name": "afterfocus",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "After focus render finished.\nCan be used to access a focus element through `event.target`.\nThis is just a duplicate of `afterfocus` from `revogr-focus.tsx`."
                },
                "complexType": {
                    "original": "FocusAfterRenderEvent",
                    "resolved": "FocusAfterRenderEvent",
                    "references": {
                        "FocusAfterRenderEvent": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::FocusAfterRenderEvent"
                        }
                    }
                }
            }, {
                "method": "roworderchanged",
                "name": "roworderchanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Before the order of `rgRow` is applied.\nTo prevent the default behavior of changing the order of `rgRow`, you can call `e.preventDefault()`."
                },
                "complexType": {
                    "original": "{ from: number; to: number }",
                    "resolved": "{ from: number; to: number; }",
                    "references": {}
                }
            }, {
                "method": "beforesorting",
                "name": "beforesorting",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "By `SortingPlugin`\n<br>Triggered immediately after header click.\n<br>First in sorting event sequence. Ff this event stops no other event called.\n<br>Use `e.preventDefault()` to prevent sorting."
                },
                "complexType": {
                    "original": "{\n    column: ColumnRegular;\n    order: 'desc' | 'asc';\n    additive: boolean;\n  }",
                    "resolved": "{ column: ColumnRegular; order: \"asc\" | \"desc\"; additive: boolean; }",
                    "references": {
                        "ColumnRegular": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnRegular"
                        }
                    }
                }
            }, {
                "method": "beforesourcesortingapply",
                "name": "beforesourcesortingapply",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "By `SortingPlugin`\n<br>Same as `beforesorting` but triggered after `beforeanysource` (when source is changed).\n<br>Use `e.preventDefault()` to prevent sorting data change."
                },
                "complexType": {
                    "original": "{\n    type: DimensionRows;\n    sorting?: SortingOrder;\n  }",
                    "resolved": "{ type: DimensionRows; sorting?: SortingOrder | undefined; }",
                    "references": {
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        },
                        "SortingOrder": {
                            "location": "import",
                            "path": "../../plugins",
                            "id": "src/plugins/index.ts::SortingOrder"
                        }
                    }
                }
            }, {
                "method": "beforesortingapply",
                "name": "beforesortingapply",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "By `SortingPlugin`\n<br> After `beforesorting`\n<br>Triggered after column data updated with new sorting order.\n<br>Use `e.preventDefault()` to prevent sorting data change."
                },
                "complexType": {
                    "original": "{\n    column: ColumnRegular;\n    order: 'desc' | 'asc';\n    additive: boolean;\n  }",
                    "resolved": "{ column: ColumnRegular; order: \"asc\" | \"desc\"; additive: boolean; }",
                    "references": {
                        "ColumnRegular": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnRegular"
                        }
                    }
                }
            }, {
                "method": "rowdragstart",
                "name": "rowdragstart",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is triggered when the row order change is started.\nTo prevent the default behavior of changing the row order, you can call `e.preventDefault()`.\nTo change the item name at the start of the row order change, you can set `e.text` to the desired new name."
                },
                "complexType": {
                    "original": "RowDragStartDetails",
                    "resolved": "{ cell: Cell; text: string; pos: PositionItem; event: MouseEvent; rowType: DimensionRows; model: any; }",
                    "references": {
                        "RowDragStartDetails": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::RowDragStartDetails"
                        }
                    }
                }
            }, {
                "method": "headerclick",
                "name": "headerclick",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "On header click."
                },
                "complexType": {
                    "original": "ColumnRegular",
                    "resolved": "ColumnRegular",
                    "references": {
                        "ColumnRegular": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnRegular"
                        }
                    }
                }
            }, {
                "method": "beforecellfocus",
                "name": "beforecellfocus",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Before the cell focus is changed.\nTo prevent the default behavior of changing the cell focus, you can call `e.preventDefault()`."
                },
                "complexType": {
                    "original": "BeforeSaveDataDetails",
                    "resolved": "BeforeSaveDataDetails",
                    "references": {
                        "BeforeSaveDataDetails": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::BeforeSaveDataDetails"
                        }
                    }
                }
            }, {
                "method": "beforefocuslost",
                "name": "beforefocuslost",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Before the grid focus is lost.\nTo prevent the default behavior of changing the cell focus, you can call `e.preventDefault()`."
                },
                "complexType": {
                    "original": "FocusedData | null",
                    "resolved": "null | { model: any; cell: Cell; colType: DimensionCols; rowType: DimensionRows; column?: ColumnRegular | undefined; }",
                    "references": {
                        "FocusedData": {
                            "location": "import",
                            "path": "./viewport.service",
                            "id": "src/components/revoGrid/viewport.service.ts::FocusedData"
                        }
                    }
                }
            }, {
                "method": "beforesourceset",
                "name": "beforesourceset",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Before main source/rows data apply.\nYou can override data source here"
                },
                "complexType": {
                    "original": "{\n    type: DimensionRows;\n    source: DataType[];\n  }",
                    "resolved": "{ type: DimensionRows; source: DataType[]; }",
                    "references": {
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        },
                        "DataType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DataType"
                        }
                    }
                }
            }, {
                "method": "beforeanysource",
                "name": "beforeanysource",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Before data apply on any source type. Can be source from pinned and main viewport.\nYou can override data source here"
                },
                "complexType": {
                    "original": "{\n    type: DimensionRows;\n    source: DataType[];\n  }",
                    "resolved": "{ type: DimensionRows; source: DataType[]; }",
                    "references": {
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        },
                        "DataType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DataType"
                        }
                    }
                }
            }, {
                "method": "aftersourceset",
                "name": "aftersourceset",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "After main source/rows updated"
                },
                "complexType": {
                    "original": "{\n    type: DimensionRows;\n    source: DataType[];\n  }",
                    "resolved": "{ type: DimensionRows; source: DataType[]; }",
                    "references": {
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        },
                        "DataType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DataType"
                        }
                    }
                }
            }, {
                "method": "afteranysource",
                "name": "afteranysource",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted after each source update, whether from the pinned or main viewport.\nUseful for tracking all changes originating from sources in both the pinned and main viewports."
                },
                "complexType": {
                    "original": "{\n    type: DimensionRows;\n    source: DataType[];\n  }",
                    "resolved": "{ type: DimensionRows; source: DataType[]; }",
                    "references": {
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        },
                        "DataType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DataType"
                        }
                    }
                }
            }, {
                "method": "beforecolumnsset",
                "name": "beforecolumnsset",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted before a column update is applied.\nListeners can use this event to perform any necessary actions or modifications before the column update is finalized."
                },
                "complexType": {
                    "original": "ColumnCollection",
                    "resolved": "{ columns: Record<DimensionCols, ColumnRegular[]>; columnByProp: Record<ColumnProp, ColumnRegular[]>; columnGrouping: ColumnGroupingCollection; maxLevel: number; sort: Record<ColumnProp, ColumnRegular>; }",
                    "references": {
                        "ColumnCollection": {
                            "location": "import",
                            "path": "../../utils/column.utils",
                            "id": "src/utils/column.utils.ts::ColumnCollection"
                        }
                    }
                }
            }, {
                "method": "beforecolumnapplied",
                "name": "beforecolumnapplied",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted before a column update is applied, after the column set is gathered and the viewport is updated.\nUseful for performing actions or modifications before the final application of the column update."
                },
                "complexType": {
                    "original": "ColumnCollection",
                    "resolved": "{ columns: Record<DimensionCols, ColumnRegular[]>; columnByProp: Record<ColumnProp, ColumnRegular[]>; columnGrouping: ColumnGroupingCollection; maxLevel: number; sort: Record<ColumnProp, ColumnRegular>; }",
                    "references": {
                        "ColumnCollection": {
                            "location": "import",
                            "path": "../../utils/column.utils",
                            "id": "src/utils/column.utils.ts::ColumnCollection"
                        }
                    }
                }
            }, {
                "method": "aftercolumnsset",
                "name": "aftercolumnsset",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Column updated"
                },
                "complexType": {
                    "original": "{\n    columns: ColumnCollection;\n    order: SortingOrder;\n  }",
                    "resolved": "{ columns: ColumnCollection; order: SortingOrder; }",
                    "references": {
                        "ColumnCollection": {
                            "location": "import",
                            "path": "../../utils/column.utils",
                            "id": "src/utils/column.utils.ts::ColumnCollection"
                        },
                        "SortingOrder": {
                            "location": "import",
                            "path": "../../plugins",
                            "id": "src/plugins/index.ts::SortingOrder"
                        }
                    }
                }
            }, {
                "method": "beforefilterapply",
                "name": "beforefilterapply",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted before applying a filter to the data source.\nUse e.preventDefault() to prevent cell focus change.\nModify if you need to change filters."
                },
                "complexType": {
                    "original": "{ collection: Record<ColumnProp, FilterCollectionItem> }",
                    "resolved": "{ collection: Record<ColumnProp, FilterCollectionItem>; }",
                    "references": {
                        "Record": {
                            "location": "global",
                            "id": "global::Record"
                        },
                        "ColumnProp": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnProp"
                        },
                        "FilterCollectionItem": {
                            "location": "import",
                            "path": "../../plugins/filter/filter.types",
                            "id": "src/plugins/filter/filter.types.ts::FilterCollectionItem"
                        }
                    }
                }
            }, {
                "method": "beforefiltertrimmed",
                "name": "beforefiltertrimmed",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted before applying a filter to the data source.\nUse e.preventDefault() to prevent the default behavior of trimming values and applying the filter.\nModify the `collection` property if you want to change the filters.\nModify the `itemsToFilter` property if you want to filter the indexes for trimming."
                },
                "complexType": {
                    "original": "{\n    collection: Record<ColumnProp, FilterCollectionItem>;\n    itemsToFilter: Record<number, boolean>;\n  }",
                    "resolved": "{ collection: Record<ColumnProp, FilterCollectionItem>; itemsToFilter: Record<number, boolean>; }",
                    "references": {
                        "Record": {
                            "location": "global",
                            "id": "global::Record"
                        },
                        "ColumnProp": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnProp"
                        },
                        "FilterCollectionItem": {
                            "location": "import",
                            "path": "../../plugins/filter/filter.types",
                            "id": "src/plugins/filter/filter.types.ts::FilterCollectionItem"
                        }
                    }
                }
            }, {
                "method": "beforetrimmed",
                "name": "beforetrimmed",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted before trimming values.\nUse e.preventDefault() to prevent the default behavior of trimming values.\nModify the `trimmed` property if you want to filter the indexes for trimming."
                },
                "complexType": {
                    "original": "{\n    trimmed: Record<number, boolean>;\n    trimmedType: string;\n    type: string;\n  }",
                    "resolved": "{ trimmed: Record<number, boolean>; trimmedType: string; type: string; }",
                    "references": {
                        "Record": {
                            "location": "global",
                            "id": "global::Record"
                        }
                    }
                }
            }, {
                "method": "aftertrimmed",
                "name": "aftertrimmed",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted after trimmed values have been applied.\nUseful for notifying when trimming of values has taken place."
                },
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                }
            }, {
                "method": "viewportscroll",
                "name": "viewportscroll",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the viewport is scrolled.\nUseful for tracking viewport scrolling events."
                },
                "complexType": {
                    "original": "ViewPortScrollEvent",
                    "resolved": "{ dimension: DimensionType; coordinate: number; delta?: number | undefined; outside?: boolean | undefined; }",
                    "references": {
                        "ViewPortScrollEvent": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ViewPortScrollEvent"
                        }
                    }
                }
            }, {
                "method": "beforeexport",
                "name": "beforeexport",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Before export\nUse e.preventDefault() to prevent export\nReplace data in Event in case you want to modify it in export"
                },
                "complexType": {
                    "original": "DataInput",
                    "resolved": "{ data: DataType[]; } & ColSource",
                    "references": {
                        "DataInput": {
                            "location": "import",
                            "path": "../../plugins/export/types",
                            "id": "src/plugins/export/types.ts::DataInput"
                        }
                    }
                }
            }, {
                "method": "beforeeditstart",
                "name": "beforeeditstart",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted before editing starts.\nUse e.preventDefault() to prevent the default edit behavior."
                },
                "complexType": {
                    "original": "BeforeSaveDataDetails",
                    "resolved": "BeforeSaveDataDetails",
                    "references": {
                        "BeforeSaveDataDetails": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::BeforeSaveDataDetails"
                        }
                    }
                }
            }, {
                "method": "aftercolumnresize",
                "name": "aftercolumnresize",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted after column resizing.\nUseful for retrieving the resized columns."
                },
                "complexType": {
                    "original": "{\n    [index: number]: ColumnRegular;\n  }",
                    "resolved": "{ [index: number]: ColumnRegular; }",
                    "references": {
                        "ColumnRegular": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnRegular"
                        }
                    }
                }
            }, {
                "method": "beforerowdefinition",
                "name": "beforerowdefinition",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted before the row definition is applied.\nUseful for modifying or preventing the default row definition behavior."
                },
                "complexType": {
                    "original": "{ vals: any; oldVals: any }",
                    "resolved": "{ vals: any; oldVals: any; }",
                    "references": {}
                }
            }, {
                "method": "filterconfigchanged",
                "name": "filterconfigchanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the filter configuration is changed"
                },
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                }
            }, {
                "method": "sortingconfigchanged",
                "name": "sortingconfigchanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the sorting configuration is changed\nSortingPlugin subsribed to this event"
                },
                "complexType": {
                    "original": "SortingConfig",
                    "resolved": "{ columns?: { prop: ColumnProp; order: Order; cellCompare?: CellCompareFunc | undefined; }[] | undefined; additive?: boolean | undefined; }",
                    "references": {
                        "SortingConfig": {
                            "location": "import",
                            "path": "../../plugins",
                            "id": "src/plugins/index.ts::SortingConfig"
                        }
                    }
                }
            }, {
                "method": "rowheaderschanged",
                "name": "rowheaderschanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emmited when the row headers are changed."
                },
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                }
            }, {
                "method": "beforegridrender",
                "name": "beforegridrender",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emmited before the grid is rendered."
                },
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                }
            }, {
                "method": "aftergridrender",
                "name": "aftergridrender",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emmited after the grid is rendered."
                },
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                }
            }, {
                "method": "aftergridinit",
                "name": "aftergridinit",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emmited after the grid is initialized. Connected to the DOM."
                },
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                }
            }, {
                "method": "additionaldatachanged",
                "name": "additionaldatachanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emmited after the additional data is changed"
                },
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                }
            }, {
                "method": "afterthemechanged",
                "name": "afterthemechanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emmited after the theme is changed"
                },
                "complexType": {
                    "original": "Theme",
                    "resolved": "string",
                    "references": {
                        "Theme": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::Theme"
                        }
                    }
                }
            }, {
                "method": "created",
                "name": "created",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emmited after grid created"
                },
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                }
            }];
    }
    static get methods() {
        return {
            "refresh": {
                "complexType": {
                    "signature": "(type?: DimensionRows | \"all\") => Promise<void>",
                    "parameters": [{
                            "name": "type",
                            "type": "DimensionRows | \"all\"",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Refreshes data viewport.\nCan be specific part as rgRow or pinned rgRow or 'all' by default.",
                    "tags": []
                }
            },
            "setDataAt": {
                "complexType": {
                    "signature": "({ row, col, colType, rowType, val, skipDataUpdate }: { row: number; col: number; val?: any; skipDataUpdate?: boolean; } & AllDimensionType) => Promise<void | undefined>",
                    "parameters": [{
                            "name": "__0",
                            "type": "{ row: number; col: number; val?: any; skipDataUpdate?: boolean | undefined; } & AllDimensionType",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "AllDimensionType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::AllDimensionType"
                        },
                        "HTMLRevogrDataElement": {
                            "location": "global",
                            "id": "global::HTMLRevogrDataElement"
                        }
                    },
                    "return": "Promise<void | undefined>"
                },
                "docs": {
                    "text": "Refreshes data at specified cell.\nUseful for performance optimization.\nNo viewport update will be triggered.",
                    "tags": [{
                            "name": "example",
                            "text": "const grid = document.querySelector('revo-grid');\ngrid.setDataAt({ row: 0, col: 0, val: 'test' }); // refresh"
                        }]
                }
            },
            "scrollToRow": {
                "complexType": {
                    "signature": "(coordinate?: number) => Promise<void>",
                    "parameters": [{
                            "name": "coordinate",
                            "type": "number",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Scrolls viewport to specified row by index.",
                    "tags": []
                }
            },
            "scrollToColumnIndex": {
                "complexType": {
                    "signature": "(coordinate?: number) => Promise<void>",
                    "parameters": [{
                            "name": "coordinate",
                            "type": "number",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Scrolls viewport to specified column by index.",
                    "tags": []
                }
            },
            "scrollToColumnProp": {
                "complexType": {
                    "signature": "(prop: ColumnProp, dimension?: DimensionTypeCol) => Promise<void>",
                    "parameters": [{
                            "name": "prop",
                            "type": "string | number",
                            "docs": ""
                        }, {
                            "name": "dimension",
                            "type": "\"rgCol\"",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "ColumnProp": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnProp"
                        },
                        "DimensionTypeCol": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionTypeCol"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Scrolls viewport to specified column by prop",
                    "tags": []
                }
            },
            "updateColumns": {
                "complexType": {
                    "signature": "(cols: ColumnRegular[]) => Promise<void>",
                    "parameters": [{
                            "name": "cols",
                            "type": "ColumnRegular[]",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "ColumnRegular": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnRegular"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Update columns",
                    "tags": []
                }
            },
            "addTrimmed": {
                "complexType": {
                    "signature": "(trimmed: Record<number, boolean>, trimmedType?: string, type?: DimensionRows) => Promise<CustomEvent<{ trimmed: Record<number, boolean>; trimmedType: string; type: string; }>>",
                    "parameters": [{
                            "name": "trimmed",
                            "type": "{ [x: number]: boolean; }",
                            "docs": ""
                        }, {
                            "name": "trimmedType",
                            "type": "string",
                            "docs": ""
                        }, {
                            "name": "type",
                            "type": "DimensionRowPin | \"rgRow\"",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "CustomEvent": {
                            "location": "global",
                            "id": "global::CustomEvent"
                        },
                        "Record": {
                            "location": "global",
                            "id": "global::Record"
                        },
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        }
                    },
                    "return": "Promise<CustomEvent<{ trimmed: Record<number, boolean>; trimmedType: string; type: string; }>>"
                },
                "docs": {
                    "text": "Add trimmed by type",
                    "tags": []
                }
            },
            "scrollToCoordinate": {
                "complexType": {
                    "signature": "(cell: Partial<Cell>) => Promise<void>",
                    "parameters": [{
                            "name": "cell",
                            "type": "{ x?: number | undefined; y?: number | undefined; }",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Partial": {
                            "location": "global",
                            "id": "global::Partial"
                        },
                        "Cell": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::Cell"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Scrolls view port to coordinate",
                    "tags": []
                }
            },
            "setCellEdit": {
                "complexType": {
                    "signature": "(rgRow: number, prop: ColumnProp, rowSource?: DimensionRows) => Promise<void>",
                    "parameters": [{
                            "name": "rgRow",
                            "type": "number",
                            "docs": ""
                        }, {
                            "name": "prop",
                            "type": "string | number",
                            "docs": ""
                        }, {
                            "name": "rowSource",
                            "type": "DimensionRowPin | \"rgRow\"",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "ColumnProp": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnProp"
                        },
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Open editor for cell.",
                    "tags": []
                }
            },
            "setCellsFocus": {
                "complexType": {
                    "signature": "(cellStart?: Cell, cellEnd?: Cell, colType?: string, rowType?: string) => Promise<void>",
                    "parameters": [{
                            "name": "cellStart",
                            "type": "Cell",
                            "docs": ""
                        }, {
                            "name": "cellEnd",
                            "type": "Cell",
                            "docs": ""
                        }, {
                            "name": "colType",
                            "type": "string",
                            "docs": ""
                        }, {
                            "name": "rowType",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Cell": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::Cell"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Set focus range.",
                    "tags": []
                }
            },
            "getSource": {
                "complexType": {
                    "signature": "(type?: DimensionRows) => Promise<DataType[]>",
                    "parameters": [{
                            "name": "type",
                            "type": "DimensionRowPin | \"rgRow\"",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "DataType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DataType"
                        },
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        }
                    },
                    "return": "Promise<DataType[]>"
                },
                "docs": {
                    "text": "Get data from source",
                    "tags": []
                }
            },
            "getVisibleSource": {
                "complexType": {
                    "signature": "(type?: DimensionRows) => Promise<any[]>",
                    "parameters": [{
                            "name": "type",
                            "type": "DimensionRowPin | \"rgRow\"",
                            "docs": "- type of source"
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        }
                    },
                    "return": "Promise<any[]>"
                },
                "docs": {
                    "text": "Get data from visible part of source\nTrimmed/filtered rows will be excluded",
                    "tags": [{
                            "name": "param",
                            "text": "type - type of source"
                        }]
                }
            },
            "getSourceStore": {
                "complexType": {
                    "signature": "(type?: DimensionRows) => Promise<Observable<DSourceState<DataType, DimensionRows>>>",
                    "parameters": [{
                            "name": "type",
                            "type": "DimensionRowPin | \"rgRow\"",
                            "docs": "- type of source"
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Observable": {
                            "location": "import",
                            "path": "../../utils",
                            "id": "src/utils/index.ts::Observable"
                        },
                        "DSourceState": {
                            "location": "import",
                            "path": "@store",
                            "id": "src/store/index.ts::DSourceState"
                        },
                        "DataType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DataType"
                        },
                        "DimensionRows": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionRows"
                        }
                    },
                    "return": "Promise<Observable<DSourceState<DataType, DimensionRows>>>"
                },
                "docs": {
                    "text": "Provides access to rows internal store observer\nCan be used for plugin support",
                    "tags": [{
                            "name": "param",
                            "text": "type - type of source"
                        }]
                }
            },
            "getColumnStore": {
                "complexType": {
                    "signature": "(type?: DimensionCols) => Promise<Observable<DSourceState<ColumnRegular, DimensionCols>>>",
                    "parameters": [{
                            "name": "type",
                            "type": "DimensionColPin | \"rgCol\"",
                            "docs": "- type of column"
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Observable": {
                            "location": "import",
                            "path": "../../utils",
                            "id": "src/utils/index.ts::Observable"
                        },
                        "DSourceState": {
                            "location": "import",
                            "path": "@store",
                            "id": "src/store/index.ts::DSourceState"
                        },
                        "ColumnRegular": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnRegular"
                        },
                        "DimensionCols": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::DimensionCols"
                        }
                    },
                    "return": "Promise<Observable<DSourceState<ColumnRegular, DimensionCols>>>"
                },
                "docs": {
                    "text": "Provides access to column internal store observer\nCan be used for plugin support",
                    "tags": [{
                            "name": "param",
                            "text": "type - type of column"
                        }]
                }
            },
            "updateColumnSorting": {
                "complexType": {
                    "signature": "(column: Pick<ColumnRegular, \"prop\" | \"cellCompare\">, order: \"asc\" | \"desc\" | undefined, additive: boolean) => Promise<void>",
                    "parameters": [{
                            "name": "column",
                            "type": "{ prop: ColumnProp; cellCompare?: CellCompareFunc | undefined; }",
                            "docs": "- column prop and cellCompare"
                        }, {
                            "name": "order",
                            "type": "\"asc\" | \"desc\" | undefined",
                            "docs": "- order to apply"
                        }, {
                            "name": "additive",
                            "type": "boolean",
                            "docs": "- if false will replace current order\n\nlater passed to SortingPlugin"
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Pick": {
                            "location": "global",
                            "id": "global::Pick"
                        },
                        "ColumnRegular": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnRegular"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Update column sorting",
                    "tags": [{
                            "name": "param",
                            "text": "column - column prop and cellCompare"
                        }, {
                            "name": "param",
                            "text": "order - order to apply"
                        }, {
                            "name": "param",
                            "text": "additive - if false will replace current order\n\nlater passed to SortingPlugin"
                        }]
                }
            },
            "clearSorting": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Clears column sorting",
                    "tags": []
                }
            },
            "getColumns": {
                "complexType": {
                    "signature": "() => Promise<ColumnRegular[]>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "ColumnRegular": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnRegular"
                        }
                    },
                    "return": "Promise<ColumnRegular[]>"
                },
                "docs": {
                    "text": "Receive all columns in data source",
                    "tags": []
                }
            },
            "clearFocus": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Clear current grid focus. Grid has no longer focus on it.",
                    "tags": []
                }
            },
            "getPlugins": {
                "complexType": {
                    "signature": "() => Promise<PluginBaseComponent[]>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "PluginBaseComponent": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::PluginBaseComponent"
                        }
                    },
                    "return": "Promise<PluginBaseComponent[]>"
                },
                "docs": {
                    "text": "Get all active plugins instances",
                    "tags": []
                }
            },
            "getFocused": {
                "complexType": {
                    "signature": "() => Promise<FocusedData | null>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "FocusedData": {
                            "location": "import",
                            "path": "./viewport.service",
                            "id": "src/components/revoGrid/viewport.service.ts::FocusedData"
                        }
                    },
                    "return": "Promise<FocusedData | null>"
                },
                "docs": {
                    "text": "Get the currently focused cell.",
                    "tags": []
                }
            },
            "getContentSize": {
                "complexType": {
                    "signature": "() => Promise<Cell>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Cell": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::Cell"
                        }
                    },
                    "return": "Promise<Cell>"
                },
                "docs": {
                    "text": "Get size of content\nIncluding all pinned data",
                    "tags": []
                }
            },
            "getSelectedRange": {
                "complexType": {
                    "signature": "() => Promise<(RangeArea & AllDimensionType) | null>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "RangeArea": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::RangeArea"
                        },
                        "AllDimensionType": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::AllDimensionType"
                        }
                    },
                    "return": "Promise<(RangeArea & AllDimensionType) | null>"
                },
                "docs": {
                    "text": "Get the currently selected Range.",
                    "tags": []
                }
            },
            "refreshExtraElements": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Refresh extra elements. Triggers re-rendering of extra elements and functions.\nPart of extraElements and registerVNode methods.\nUseful for plugins.",
                    "tags": []
                }
            },
            "getProviders": {
                "complexType": {
                    "signature": "() => Promise<PluginProviders | undefined>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "PluginProviders": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::PluginProviders"
                        }
                    },
                    "return": "Promise<PluginProviders | undefined>"
                },
                "docs": {
                    "text": "Get all providers for grid\nUseful for external grid integration",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "element"; }
    static get watchers() {
        return [{
                "propName": "columnTypes",
                "methodName": "columnTypesChanged"
            }, {
                "propName": "columns",
                "methodName": "columnChanged"
            }, {
                "propName": "disableVirtualX",
                "methodName": "disableVirtualXChanged"
            }, {
                "propName": "rowSize",
                "methodName": "rowSizeChanged"
            }, {
                "propName": "theme",
                "methodName": "themeChanged"
            }, {
                "propName": "source",
                "methodName": "dataSourceChanged"
            }, {
                "propName": "pinnedBottomSource",
                "methodName": "dataSourceChanged"
            }, {
                "propName": "pinnedTopSource",
                "methodName": "dataSourceChanged"
            }, {
                "propName": "disableVirtualY",
                "methodName": "disableVirtualYChanged"
            }, {
                "propName": "rowDefinitions",
                "methodName": "rowDefChanged"
            }, {
                "propName": "trimmedRows",
                "methodName": "trimmedRowsChanged"
            }, {
                "propName": "grouping",
                "methodName": "groupingChanged"
            }, {
                "propName": "stretch",
                "methodName": "applyStretch"
            }, {
                "propName": "filter",
                "methodName": "applyFilter"
            }, {
                "propName": "sorting",
                "methodName": "applySorting"
            }, {
                "propName": "rowHeaders",
                "methodName": "rowHeadersChange"
            }, {
                "propName": "registerVNode",
                "methodName": "registerOutsideVNodes"
            }, {
                "propName": "additionalData",
                "methodName": "additionalDataChanged"
            }, {
                "propName": "rtl",
                "methodName": "rtlChanged"
            }, {
                "propName": "plugins",
                "methodName": "pluginsChanged"
            }];
    }
    static get listeners() {
        return [{
                "name": "touchstart",
                "method": "mousedownHandle",
                "target": "document",
                "capture": false,
                "passive": true
            }, {
                "name": "mousedown",
                "method": "mousedownHandle",
                "target": "document",
                "capture": false,
                "passive": true
            }, {
                "name": "touchend",
                "method": "mouseupHandle",
                "target": "document",
                "capture": false,
                "passive": true
            }, {
                "name": "mouseup",
                "method": "mouseupHandle",
                "target": "document",
                "capture": false,
                "passive": true
            }, {
                "name": "rowdragstartinit",
                "method": "onRowDragStarted",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "rowdragendinit",
                "method": "onRowDragEnd",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "roworderchange",
                "method": "onRowOrderChange",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "rowdragmoveinit",
                "method": "onRowDrag",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "rowdragmousemove",
                "method": "onRowMouseMove",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "celleditapply",
                "method": "onCellEdit",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "rangeeditapply",
                "method": "onRangeEdit",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "selectionchangeinit",
                "method": "onRangeChanged",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "rowdropinit",
                "method": "onRowDropped",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "beforeheaderclick",
                "method": "onHeaderClick",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "beforecellfocusinit",
                "method": "onCellFocus",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=revo-grid.js.map
