{"version":3,"file":"column.utils.js","sourceRoot":"","sources":["../../src/utils/column.utils.ts"],"names":[],"mappings":"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","sourcesContent":["import isArray from 'lodash/isArray';\nimport reduce from 'lodash/reduce';\n\nimport type {\n  ColumnData,\n  ColumnGrouping,\n  ColumnProp,\n  ColumnRegular,\n  ColumnTypes,\n  DataType,\n  DimensionCols,\n  ViewSettingSizeProp,\n} from '@type';\nimport { columnTypes, type Group as StoreGroup } from '@store';\n\nexport type ColumnItems = Record<DimensionCols, ColumnRegular[]>;\nexport interface ColumnGroup extends StoreGroup {\n  level: number;\n}\nexport type ColumnGroupingCollection = Record<DimensionCols, ColumnGroup[]>;\n\nexport function getCellData(val?: any) {\n  if (typeof val === 'undefined' || val === null) {\n    return '';\n  }\n  return val;\n}\n\nexport function getCellRaw(model: DataType = {}, column?: ColumnRegular) {\n  if (!column) {\n    return;\n  }\n  if (column.cellParser) {\n    return column.cellParser(model, column);\n  }\n  return model[column.prop];\n}\n\nexport function getCellDataParsed(model: DataType, column: ColumnRegular) {\n  return getCellData(getCellRaw(model, column));\n}\n\n/**\n * Column collection definition.\n * Used to access indexed data for columns.\n * Can be accessed via different events.\n */\nexport type ColumnCollection = {\n  /**\n   * Columns as they are in stores\n   */\n  columns: Record<DimensionCols, ColumnRegular[]>;\n  /**\n   * Columns indexed by prop for quick access, it's possible to have multiple columns with same prop but not recommended\n   */\n  columnByProp: Record<ColumnProp, ColumnRegular[]>;\n  /**\n   * Grouped columns\n   */\n  columnGrouping: ColumnGroupingCollection;\n  /**\n   * Max level of grouping\n   */\n  maxLevel: number;\n  /**\n   * Sorting\n   */\n  sort: Record<ColumnProp, ColumnRegular>;\n};\n\n/**\n * Get column type from column data\n */\nexport function getColumnType(rgCol: ColumnRegular): DimensionCols {\n  if (rgCol.pin) {\n    return rgCol.pin;\n  }\n  return 'rgCol';\n}\n\nexport function getColumnSizes(cols: ColumnRegular[]): ViewSettingSizeProp {\n  const res: ViewSettingSizeProp = {};\n  for (const [i, c] of cols.entries()) {\n    if (c.size) {\n      res[i] = c.size;\n    }\n  }\n  return res;\n}\n\n\n/**\n * Check if column is grouping column\n */\nexport function isColGrouping(\n  colData: ColumnGrouping | ColumnRegular,\n): colData is ColumnGrouping {\n  return !!(colData as ColumnGrouping).children;\n}\n\n/**\n * This function is used to create a collection of columns.\n */\nexport function getColumns(\n  columns: ColumnData,\n  level = 0,\n  types?: ColumnTypes,\n  resFromRoot?: Partial<ColumnCollection>\n): ColumnCollection {\n  const collection: ColumnCollection = {\n    // columns as they are in stores per type\n    columns: {\n      rgCol: [],\n      colPinStart: [],\n      colPinEnd: [],\n    },\n    // columns indexed by prop for quick access\n    columnByProp: {},\n    // column grouping\n    columnGrouping: {\n      rgCol: [],\n      colPinStart: [],\n      colPinEnd: [],\n    },\n    // sorting\n    sort: {},\n    // max depth level for column grouping\n    maxLevel: level,\n  };\n\n  return reduce(\n    columns,\n    (res: ColumnCollection, colData: ColumnGrouping | ColumnRegular) => {\n      // Grouped column\n      if (isColGrouping(colData)) {\n        res = gatherGroup(\n          res,\n          colData,\n          getColumns(colData.children, level + 1, types, res),\n          resFromRoot?.columns,\n          level,\n        );\n        return res;\n      }\n      // Column type\n      const columnDefinitionFromType = colData.columnType && types?.[colData.columnType];\n      // Regular column\n      const regularColumn = {\n        ...columnDefinitionFromType,\n        ...colData,\n      };\n      // Regular column, no Pin\n      if (!regularColumn.pin) {\n        res.columns.rgCol.push(regularColumn);\n        // Pin\n      } else {\n        res.columns[regularColumn.pin].push(regularColumn);\n      }\n      if (regularColumn.order) {\n        res.sort[regularColumn.prop] = regularColumn;\n      }\n      // it's possible that some columns have same prop, but better to avoid it\n      if (!res.columnByProp[regularColumn.prop]) {\n        res.columnByProp[regularColumn.prop] = [];\n      }\n      res.columnByProp[regularColumn.prop].push(regularColumn);\n\n      // trigger setup hook if present\n      regularColumn.beforeSetup?.(regularColumn);\n      return res;\n    },\n    collection,\n  );\n}\n\nexport function gatherGroup<T extends ColumnCollection>(\n  res: T,\n  colData: ColumnGrouping,\n  collection: T,\n  existingColumnsByType?: ColumnCollection['columns'],\n  level = 0,\n): T {\n  // group template\n  const group: ColumnGroup = {\n    ...colData,\n    level,\n    indexes: [],\n  };\n\n  // check columns for update\n  columnTypes.forEach(type => {\n    const resultItem = res.columns[type];\n    const collectionItem = collection.columns[type];\n\n    // if column data\n    if (isArray(resultItem) && isArray(collectionItem)) {\n\n      // fill grouping\n      const itemLength = collectionItem.length;\n      if (itemLength) {\n        const columnLength = [...(existingColumnsByType?.[type] || []), ...resultItem].length;\n        // fill columns\n        resultItem.push(...collectionItem);\n\n        // fill indexes per each viewport\n        res.columnGrouping[type].push({\n          ...group,\n          indexes: Array(itemLength).fill(columnLength).map((v, i) => v + i),\n        });\n      }\n    }\n  });\n  // merge column groupings\n  for (let k in collection.columnGrouping) {\n    const key = k as DimensionCols;\n    const collectionItem = collection.columnGrouping[key];\n    res.columnGrouping[key].push(...collectionItem);\n  }\n  res.maxLevel = Math.max(res.maxLevel, collection.maxLevel);\n  res.sort = { ...res.sort, ...collection.sort };\n  res.columnByProp = {\n    ...res.columnByProp,\n    ...collection.columnByProp,\n  };\n  return res;\n}\n\nfunction findColumn(\n  columns: ColumnData,\n  prop: ColumnProp,\n): ColumnRegular | undefined {\n  for (const c of columns) {\n    if (isColGrouping(c)) {\n      const found = findColumn(c.children, prop);\n      if (found) {\n        return found;\n      }\n    } else if (c.prop === prop) {\n      return c;\n    }\n  }\n  return undefined;\n}\n\nexport function getColumnByProp(\n  columns: ColumnData,\n  prop: ColumnProp,\n): ColumnRegular | undefined {\n  return findColumn(columns, prop);\n}\n"]}