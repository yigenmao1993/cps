/*!
 * Built by Revolist OU ❤️
 */
import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';
import { E as EDIT_INPUT_WR } from './consts.js';
import { K as KeyCodesEnum, O as OsPlatform, c as codesLetter, k as keyValues } from './platform.js';
import { t as timeout } from './index2.js';

function isMetaKey(code) {
    const keys = [
        KeyCodesEnum.ARROW_DOWN,
        KeyCodesEnum.ARROW_UP,
        KeyCodesEnum.ARROW_LEFT,
        KeyCodesEnum.ARROW_RIGHT,
        KeyCodesEnum.HOME,
        KeyCodesEnum.END,
        KeyCodesEnum.DELETE,
        KeyCodesEnum.BACKSPACE,
        KeyCodesEnum.F1,
        KeyCodesEnum.F2,
        KeyCodesEnum.F3,
        KeyCodesEnum.F4,
        KeyCodesEnum.F5,
        KeyCodesEnum.F6,
        KeyCodesEnum.F7,
        KeyCodesEnum.F8,
        KeyCodesEnum.F9,
        KeyCodesEnum.F10,
        KeyCodesEnum.F11,
        KeyCodesEnum.F12,
        KeyCodesEnum.TAB,
        KeyCodesEnum.PAGE_DOWN,
        KeyCodesEnum.PAGE_UP,
        KeyCodesEnum.ENTER,
        KeyCodesEnum.ESCAPE,
        KeyCodesEnum.SHIFT,
        KeyCodesEnum.CAPS_LOCK,
        KeyCodesEnum.ALT,
    ];
    return keys.indexOf(code) !== -1;
}
// navigator.platform
function isCtrlKey(code, platform) {
    if (platform.includes(OsPlatform.mac)) {
        return [
            KeyCodesEnum.COMMAND_LEFT,
            KeyCodesEnum.COMMAND_RIGHT,
            KeyCodesEnum.COMMAND_FIREFOX,
        ].includes(code);
    }
    return code === KeyCodesEnum.CONTROL;
}
function isCtrlMetaKey(code) {
    return [
        KeyCodesEnum.CONTROL,
        KeyCodesEnum.COMMAND_LEFT,
        KeyCodesEnum.COMMAND_RIGHT,
        KeyCodesEnum.COMMAND_FIREFOX,
    ].includes(code);
}
function isClear(code) {
    return codesLetter.BACKSPACE === code || codesLetter.DELETE === code;
}
function isTab(code) {
    return codesLetter.TAB === code;
}
function isTabKeyValue(key) {
    return keyValues.TAB === key;
}
function isEnterKeyValue(key) {
    return keyValues.ENTER === key;
}
function isCut(event) {
    return ((event.ctrlKey && event.code === 'KeyX') || // Ctrl + X on Windows
        (event.metaKey && event.code === 'KeyX')); // Cmd + X on Mac
}
function isCopy(event) {
    return ((event.ctrlKey && event.code === 'KeyC') || // Ctrl + C on Windows
        (event.metaKey && event.code === 'KeyC')); // Cmd + C on Mac
}
function isPaste(event) {
    return ((event.ctrlKey && event.code === 'KeyV') || // Ctrl + V on Windows
        (event.metaKey && event.code === 'KeyV')); // Cmd + V on Mac
}
function isAll(event) {
    return ((event.ctrlKey && event.code === 'KeyA') || // Ctrl + A on Windows
        (event.metaKey && event.code === 'KeyA')); // Cmd + A on Mac
}

class TextEditor {
    constructor(data, saveCallback) {
        this.data = data;
        this.saveCallback = saveCallback;
        this.editInput = null;
        this.element = null;
        this.editCell = undefined;
    }
    /**
     * Callback triggered on cell editor render
     */
    async componentDidRender() {
        var _a;
        if (this.editInput) {
            await timeout();
            (_a = this.editInput) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }
    onKeyDown(e) {
        const isEnter = isEnterKeyValue(e.key);
        const isKeyTab = isTab(e.key);
        if ((isKeyTab || isEnter) &&
            e.target &&
            this.saveCallback &&
            !e.isComposing) {
            // blur is needed to avoid autoscroll
            this.beforeDisconnect();
            // request callback which will close cell after all
            this.saveCallback(this.getValue(), isKeyTab);
        }
    }
    /**
     * IMPORTANT: Prevent scroll glitches when editor is closed and focus is on current input element.
     */
    beforeDisconnect() {
        var _a;
        (_a = this.editInput) === null || _a === void 0 ? void 0 : _a.blur();
    }
    /**
     * Get value from input
     */
    getValue() {
        var _a;
        return (_a = this.editInput) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Render method for Editor plugin.
     * Renders input element with passed data from cell.
     * @param {Function} h - h function from stencil render.
     * @param {Object} _additionalData - additional data from plugin.
     * @returns {VNode} - input element.
     */
    render(h, _additionalData) {
        var _a, _b;
        return h('input', {
            type: 'text',
            enterKeyHint: 'enter',
            // set input value from cell data
            value: (_b = (_a = this.editCell) === null || _a === void 0 ? void 0 : _a.val) !== null && _b !== void 0 ? _b : '',
            // save input element as ref for further usage
            ref: (el) => {
                this.editInput = el;
            },
            // listen to keydown event on input element
            onKeyDown: (e) => this.onKeyDown(e),
        });
    }
}

// is edit input
function isEditInput(el) {
    return !!(el === null || el === void 0 ? void 0 : el.closest(`.${EDIT_INPUT_WR}`));
}
// Type guard for EditorCtrConstructible
function isEditorCtrConstructible(editor) {
    return typeof editor === 'function' && typeof editor.prototype === 'object';
}

const revogrEditStyleCss = "revogr-edit{display:block;position:absolute;background-color:#fff}revogr-edit input{height:100%;width:100%;box-sizing:border-box}revogr-edit revo-dropdown{height:100%}revogr-edit revo-dropdown.shrink fieldset legend>span{display:none}";

const RevoEdit = /*@__PURE__*/ proxyCustomElement(class RevoEdit extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.cellEdit = createEvent(this, "celleditinit", 7);
        this.closeEdit = createEvent(this, "closeedit", 7);
        /**
         * Save on editor close. Defines if data should be saved on editor close.
         */
        this.saveOnClose = false;
        this.currentEditor = null;
        this.preventSaveOnClose = false;
    }
    /**
     * Cancel pending changes flag. Editor will be closed without autosave.
     */
    async cancelChanges() {
        this.preventSaveOnClose = true;
    }
    /**
     * Before editor got disconnected.
     * Can be triggered multiple times before actual disconnect.
     */
    async beforeDisconnect() {
        var _a, _b;
        (_b = (_a = this.currentEditor) === null || _a === void 0 ? void 0 : _a.beforeDisconnect) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    onAutoSave() {
        var _a, _b, _c;
        this.preventSaveOnClose = true;
        const val = (_b = (_a = this.currentEditor) === null || _a === void 0 ? void 0 : _a.getValue) === null || _b === void 0 ? void 0 : _b.call(_a);
        // For Editor plugin internal usage.
        // When you want to prevent save and use custom save of your own.
        if ((_c = this.currentEditor) === null || _c === void 0 ? void 0 : _c.beforeAutoSave) {
            const canSave = this.currentEditor.beforeAutoSave(val);
            if (canSave === false) {
                return;
            }
        }
        this.onSave(val, true);
    }
    /**
     * Callback triggered when cell editor saved.
     * Closes editor when called.
     * @param preventFocus - if true, editor will not be closed & next cell will not be focused.
     */
    onSave(val, preventFocus) {
        this.preventSaveOnClose = true;
        if (this.editCell) {
            this.cellEdit.emit({
                rgCol: this.editCell.x,
                rgRow: this.editCell.y,
                type: this.editCell.type,
                prop: this.editCell.prop,
                val,
                preventFocus,
            });
        }
    }
    componentWillRender() {
        // Active editor present and not yet closed.
        if (this.currentEditor || !this.column) {
            return;
        }
        this.preventSaveOnClose = false;
        // Custom editor usage.
        // Start with TextEditor (editors/text.tsx) for Custom editor.
        // It can be class or function
        if (this.editor) {
            // if editor is constructible
            if (isEditorCtrConstructible(this.editor)) {
                this.currentEditor = new this.editor(this.column, 
                // save callback
                (e, preventFocus) => {
                    this.onSave(e, preventFocus);
                }, 
                // cancel callback
                focusNext => {
                    this.preventSaveOnClose = true;
                    this.closeEdit.emit(focusNext);
                });
                // if editor is function
            }
            else {
                this.currentEditor = this.editor(this.column, 
                // save callback
                (e, preventFocus) => {
                    this.onSave(e, preventFocus);
                }, 
                // cancel callback
                focusNext => {
                    this.preventSaveOnClose = true;
                    this.closeEdit.emit(focusNext);
                });
            }
            return;
        }
        // Default text editor usage
        this.currentEditor = new TextEditor(this.column, (e, preventFocus) => this.onSave(e, preventFocus));
    }
    componentDidRender() {
        var _a, _b;
        if (!this.currentEditor) {
            return;
        }
        this.currentEditor.element = this.element.firstElementChild;
        (_b = (_a = this.currentEditor).componentDidRender) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    disconnectedCallback() {
        var _a, _b;
        if (this.saveOnClose) {
            // Can not be cancelled by `preventSaveOnClose` prop.
            // Editor requires `getValue` to be able to save.
            if (!this.preventSaveOnClose) {
                this.onAutoSave();
            }
        }
        this.preventSaveOnClose = false;
        if (!this.currentEditor) {
            return;
        }
        (_b = (_a = this.currentEditor).disconnectedCallback) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.currentEditor.element = null;
        this.currentEditor = null;
    }
    render() {
        if (this.currentEditor) {
            this.currentEditor.editCell = this.editCell;
            return (h(Host, { class: EDIT_INPUT_WR }, this.currentEditor.render(h, this.additionalData)));
        }
        return '';
    }
    get element() { return this; }
    static get style() { return revogrEditStyleCss; }
}, [256, "revogr-edit", {
        "editCell": [16, "edit-cell"],
        "column": [16],
        "editor": [16],
        "saveOnClose": [4, "save-on-close"],
        "additionalData": [8, "additional-data"],
        "cancelChanges": [64],
        "beforeDisconnect": [64]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["revogr-edit"];
    components.forEach(tagName => { switch (tagName) {
        case "revogr-edit":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, RevoEdit);
            }
            break;
    } });
}

export { RevoEdit as R, TextEditor as T, isCtrlKey as a, isCtrlMetaKey as b, isClear as c, isTab as d, isTabKeyValue as e, isEnterKeyValue as f, isCut as g, isCopy as h, isMetaKey as i, isPaste as j, isAll as k, isEditInput as l, isEditorCtrConstructible as m, defineCustomElement as n };
//# sourceMappingURL=revogr-edit2.js.map

//# sourceMappingURL=revogr-edit2.js.map